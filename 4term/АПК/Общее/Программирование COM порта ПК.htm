<html><head>
	<title>Программирование COM порта ПК</title>
	
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
	<meta name="Author" content="Electron18">
    	<meta name="Keywords" content="COM port, СОМ рорт, программирование COM порта">
    	<meta name="Description" content="Описание способов программирования COM порта">

	</head><body style="FONT-SIZE: 12pt" text="black" bgcolor="#D3E3E3">
		<a target="_parent" href="http://www.softelectro.ru/proglang_en.html" title="english"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/england.gif" align="right" border="no"></a>
		<a target="_parent" href="http://www.softelectro.ru/proglang.html" title="русский"><img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/russia.gif" align="right" border="no"></a>

		
		<a target="_parent" href="http://www.softelectro.ru/index.html"> Главная  </a>&nbsp;
		<a target="_parent" href="http://www.softelectro.ru/proglang.html">Назад </a>&nbsp;
		<br><br>
		<hr>
		
		
		

		<h1> Программирование COM порта </h1>
			<p align="right">
		
		Автор: Electron18 <br>
		www.softelectro.ru &nbsp; &nbsp;<br>
		2009 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
		 electron18@softelectro.ru
		
		</p>
		<dl><big>Содержание:</big>
		    	
				
				
			<dt><a href="#M10"> §1.Описание COM портов персонального компьютера IBM XT</a>
				</dt><dd><a href="#M11">1.1 Основные свойства COM портов</a>
				</dd><dd><a href="#M12">1.2 Технические характеристики COM портов</a>
				</dd><dd><a href="#M13">1.3 Назначение сигналов СОМ порта по стандарту RS-232C</a>
				</dd><dd><a href="#M14">1.4 Уровни сигналов UART</a>
				</dd><dd><a href="#M15">1.5 Передача данных через UART</a>
				</dd><dd><a href="#M16">1.6 Соединительные кабели</a>
				</dd><dd><a href="#M17">1.7 Организация обмена данных при аппаратном режиме синхронизации</a>
				</dd><dd><a href="#M18">1.8 Организация обмена данных при программном режиме синхронизации</a>
				</dd><dd><a href="#M19">1.9 Описание контрольных битов (Parity Control Bit)</a>
				</dd><dd><a href="#M20">1.10 ASCII кодовая таблица</a>
				</dd><dd><a href="#M21">1.11 Аппаратная реализация СОМ портов</a>
				</dd><dd><a href="#M22">1.12 Программная реализация UART</a>
				</dd><dd><a href="#M23">1.13 Диагностический режим работы UART</a>
			</dd><dt><a href="#M24"> §2 Программирование COM-порта</a>
				</dt><dd><dl><dt><a href="#M25">2.1. Программирование в MS-DOS</a>
						</dt><dd><a href="#M26">2.1.1. Программирование СОМ-порта прямым кодом микропроцессора</a>
						</dd><dd><a href="#M27">2.1.2. Программирование СОМ-порта с помощью функций BIOS</a>
						</dd><dd><a href="#M28">2.1.3. Программирование СОМ-порта с помощью средств MS-DOS</a>
					</dd></dl>
				</dd><dd><dl><dt><a href="#M29">2.2. Программирование в Windows</a>	
						</dt><dd><a href="#M30">2.2.1. Программирование СОМ-порта с помощью API функций Windows</a>
						</dd><dd><a href="#M31">2.2.2. Программирование СОМ-порта с помощью внешних компонент ActiveX</a>
						</dd><dt><a href="#M34"> Приложение 1. Примеры программирования </a>
				    </dt></dl>
		</dd></dl>
		

<a name="M10"></a>
		<h2>§1.Описание COM портов персонального компьютера IBM XT.</h2>
		

<a name="M11"></a>
		<h3>1.1 Основные свойства COM портов.</h3>
		<p>Работа коммуникационных портов реализована на универсальных асинхронных приемопередатчиках UART.<br>
			UART- это микросхемы, которые работают по стандарту RS-232C.
			Для СОМ порта компьютера используется 9-ти штырьковый разъем DE9p согласно стандарта TIA-574.
			В этом разъеме используется шесть сервисных сигналов и два канала обмена последовательными данными.
		</p>
		<strong>Основные свойства СОМ портов:</strong>
		<dl>
			<dt><strong>1.Полнодуплексный обмен данными. </strong>
				</dt><dd>Означает, что можно одновременно передавать и принимать 
поток данных. 
					Существуют два аппаратно и программно независимых канала передачи 
данных. 
					Один канал для передачи данных, другой канал для приема данных. 
					Причем COM-портам безразлично, чем занят процессор в это время, у 
них присутствуют собственные буферы приема и передачи данных. 
					В этих буферах данные выстраиваться в очередь на передачу и очередь
 на прочтение данных процессором. 
					Любая программа может обратиться к СОМ-порту и получить данные из 
его буфера, тем самым очистив его. 
					Естественно буферы не безграничны, их размер задается при 
конфигурировании портов. 
					Интерфейсы RS-485, Modbus, USB и др. (за исключением сетевых 
протоколов) являются полудуплексными и физически не способны вести обмен
 данными в обоих направлениях одновременно.
			</dd><dt><strong>2.Набор сервисных сигналов</strong>
				</dt><dd>Сервисные сигналы, предусмотренные стандартом RS-232c, 
позволяют организовать обмен данными между двумя устройствами 
одновременно в обоих направлениях. 
					Сервисные сигналы представлены отдельными цифровыми входами и 
выходами с памятью.  
					Например, кода по телефону на модем поступал звонок со станции, 
модем по 9-му контакту (RI) сообщал РС, что ему позвонили, и начиналась 
процедура обмена данных. 
					Причем с помощью сервисных сигналов РС и модем могли приостановить 
обмен данных или заставить повторить их. 
					Вариантов использования сервисных сигналов большое множество. 
					Разработчик может использовать их по своему усмотрению. 
					Например, с помощью этих сигналов удобно опрашивать контакты 
концевых выключателей или фотодатчиков, а также можно включать/выключать
 различные устройства или запитывать слаботочное устройство.

			</dd><dt><strong>3.Программная независимость</strong>
				</dt><dd>UART полностью реализован аппаратно и не зависит от программного обеспечения и ОС.
			</dd><dt><strong>4. Асинхронная передача данных по каналу связи </strong>
				</dt><dd>Означает то, что РС может послать данные на конечное 
устройство, не заботясь о синхронности их поступления. 
				Конечное устройство само подстраивается под полученные данные. 
				В синхронных протоколах для этого служит специальный сигнал, 
передающийся по отдельному проводу. 
				В коммуникационных портах синхросигнал встроен в каждый передаваемый
 символ, в виде стартового и стопового бита.
				Метод, которым синхронизируются данные по стандарту RS-232С, стал 
общеупотребительным для всех асинхронных  протоколов обмена данными.
		</dd></dl>

<a name="M12"></a>		
		<h3>1.2 Технические характеристики COM портов</h3>
		<p>Рис.1 Вид разъёмов СОМ1 и СОМ2 на материнской плате. </p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/21.jpg" align="bottom" alt="COM-port RS-232">
		<ul>
			<li>Тип разъема:DE9p(DB9P) или DB25P male (папа),  ответная часть DE9s(DB9s) или DB25s femini (мама)
			</li><li>Аппаратная реализация:  микросхемы UART  intel8250/16450/16550
			</li><li>Уровень сигнала для TxD, RxD:   1 = -3...-12 в;      0=+3...+12 в (сигналы инвертированы)
			</li><li>Уровень сигналов RTS, DTR, CTS, DSR, DCD, RI:  1 (True)=+3...+12в ;  0 (False)= -3...-12в
			</li><li>Зона нечувствительности:  -3...+3 в
			</li><li>Количество портов IBM XT: четыре  COM1, COM2, COM3, COM4
			</li><li>Адреса в пространстве ввода/вывода:  COM1=3F8h, COM2=2F8h, COM3=3E8h, COM4=2E8h
			</li><li>Аппаратные прерывания: COM1,COM3= IRQ4(IQ11)       COM2,COM4= IRQ3(IQ10)
			</li><li>Функции BIOS:   14h (инициализация, запись, чтение, опрос состояния, настройка)
			</li><li>Стандартная скорость, бит/сек:  
50,75,110,150,300,600,1200,1800,2000,2400,3600,4800,7200,9600,14400,19200,28800,38400,57600,115200

			</li><li>Максимальная скорость, бит/сек: 1 500 000
			</li><li>Количество бит данных в переданном символе:   5,6,7,8
			</li><li>Длина стопового бита:  1, 1.5, 2
			</li><li>Режимы контрольного бита(Parity): N(None), E(Even), M(Mark), O(Odd), S(Space)
			</li><li>Режимы синхронизации обмена (Handshaking): 0-None, 1-XOnXoff, 2-RTS, 3-RTSXOnXoff
			</li><li>Канал передачи данных (инверсный) :  TxD (3)-GND(5)
			</li><li>Канал приёма данных (инверсный): RxD(2)-GND(5)
			</li><li>Выходные сервисные сигналы: RTS(7)-CND(5);     DTR(6)-GND(5) 
			</li><li>Входные сервисные сигналы: CTS(8)-GND(5); DSR(6)-GND(5); DCD(1)-GND(5); RI(9)-GND(5)      
			</li><li>Расстояния связи: стандартное - 25ft( 7.62м), максимальное (определено многими факторами)
			
		</li></ul>
		<br>
<a name="M13"></a>
		<h3>1.3 Назначение сигналов СОМ порта по стандарту RS-232C.</h3>
		<ul>
			
			<li>GND- Ground, (общий) второй провод для всех сигналов.(Сигналы передаются всегда по двум проводам!)
			</li><li>TxD- Transmited Data, асинхронный канал для передачи данных.
			</li><li>RxD- Received Data, асинхронный канал для приема данных.
			</li><li>RTS- Request To Send (запрос на передачу),  Выход который 
говорит о том, что у компьютера есть данные для передачи по каналу TxD 
для конечного устройства.
			</li><li>DTR- Data Terminal Ready(готовность терминала данных), Выход
 который говорит о том, что компьютер(терминал) готов к обмену данными с
 конечным устройством
			</li><li>CTS- Clear To Send (очищен для передачи) Вход, который 
говорит о том, что конечное устройство готово принимать данные от 
терминала по каналу TxD. 
					Обычно этот сигнал выставляет конечное устройство после того, как 
оно получит от компьютера сигнал RTS=True(запрос на передачу) и будет 
готово принять данные от компьютера. 
					Если конечное устройство не выставит сигнал CTS=True, то передача 
по каналу TxD не начнется. 
					Данный сигнал используется для аппаратного управления потоками 
данных
			</li><li>DSR- Data Set Ready(установка данных готова), Вход который 
говорит о том, что конечное устройство выполнило все установки и готово 
начать передавать и принимать данные от компьютера.  
					Если конечное устройство модем, то установка DSR=True 
воспринимается компьютером(терминалом) так, что модем уже установил 
связь с другим модемом и готов начать процедуру обмена между двумя 
компьютерами оснащенных модемами
			</li><li>DCD- Data Carrier Detected(обнаружен носитель информации), 
Вход который информирует компьютер(терминал) об обнаружении другого 
терминала, то есть конечное устройство , например модем, обнаружил 
другой модем, который хочет инициализировать обмен данных между 
терминалами. 
					Модем выставляет сигнал DCD=True, который обнаруживается на входе 
компьютера(терминала).
					Если терминал готов  к обмену данными, то он на сигнал DCD=True 
должен выставить сигнал готовности терминала к обмену данными DTR=True, 
после чего начинается обмен данными между двумя терминалами.
			</li><li>RI- Ring Indicator(индикатор звонка), Вход который говорит 
компьютеру(терминалу) что на конечное устройство поступает сигнал 
вызова. 
					Например, на модем поступил сигнал вызова с телефонной станции, 
совсем не обязательно, что этот вызов закончится обменом данных. 
			
			</li><li>PG - Protective Ground. Защитное заземление.
		</li></ul>
		Рис.2 Нумерация контактов для разъёмов COM-порта<br>
		<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/pin_rs232.gif" align="bottom" alt="pin COM-port">		
<a name="M14"></a>		
		<h3>1.4 Уровни сигналов UART</h3>
		<p>UART использует уровни сигналов -12в....+12в . 
			Зона нечувствительности, то есть отсутствие сигналов считается напряжение  -3в...+3в. 
			При этом обратите внимания, что принимаемые/передаваемые данные инвертированы.
		</p>

		<p>Рис.3  Уровни сигналов UART по стандарту RS-232c</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/001.gif" align="bottom" alt="Уровни сигналов RS-232C">
		<ul>Исходные состояния
			<li>порт не инициализирован - на всех линиях напряжения  находятся в диапазоне -3в...+3в
			</li><li>режим ожидания - на всех линиях напряжение находится в диапазоне -3в...-12в
		</li></ul>
		<br>
<a name="M15"></a>
		<h3>1.5 Передача данных через UART </h3>
		<p>При передаче данных символы передаются из буфера передатчика последовательно (первым пришел- первым вышел). 
			Специально назвал  символами , а не байтами, так как символы могут иметь размер от 5 до 8 бит. 
			Каждый переданный символ снабжается стартовым и стоповым битами, предназначенным  для синхронизации на приемной стороне. 
			После стартового бита следуют биты данных, начиная с младшего бита и заканчивая старшим. 
			За последним битом данных символа может следовать бит паритета, служащий для обнаружения ошибки  передачи битов данных. 
			Последним передается стоповый бит, который необходим для временного разделения переданных символов
		</p>
		<p>Рис.4  Показана передача символов "0" "0" без паритета, с одним стоповым битом</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/002.gif" align="bottom" alt="Передача символов в RS-232C">
		<p>На рисунке 4 хорошо видно, что стоповый бит разделяет два переданных символа. 
			При необходимости можно увеличить этот интервал до 2 стоповых битов, если конечное устройство не успевает разделять символы.
		</p>
		<p>Рис.5  Показана передача символов "0" "0" с проверкой на четность (EVEN), с одним стоповым битом</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/003.gif" align="bottom" alt="Передача символов с проверкой на четность в RS-232C">
		
		<br>
<a name="M16"></a>
		<h3>1.6 Соединительные кабели</h3>
		<p> <strong> Нуль-модемное соединение двух COM портов.</strong></p>
		<p>При таком соединении компьютеры(терминалы) соединяются между собой 
непосредственно через СОМ-порты, без использования модемов.
  
			Так как компьютеры обладают большой скоростью обработки данных, то 
синхронизировать их работу не нужно. 
			Поэтому предполагается, что режим синхронизации обмена (Handshaking):
 0-None, то есть сервисные сигналы не влияют на процедуры обмена 
данными.  
			Для этого используется нуль-модемный кабель.
		</p>
		<p>Рис.6     Нуль-модемный кабель для  Handshaking = 0 (None)</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/004.gif" align="bottom" alt="Нуль-модемный кабель">
		<p>Так как режим синхронизации обмена на СОМ портах может быть 
включен, то часто сервисные сигналы СОМ портов замыкают самих на себя, 
тем самым исключая их влияния на процедуру обмена.
		</p>
		<p>Рис.7   Нуль-модемный кабель для любых режимов Handshaking</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/005.gif" align="bottom" alt="Нуль-модемный кабель RS-232">
		<p>Если необходимо можно использовать полный кабель, но  при этом 
СОМ-порты должны быть настроены на аппаратную синхронизацию обмена.<br>
			Данный режим используют когда устройство не успевает перерабатывать 
информацию полученную по СОМ-порту (меделенное устройство или PC).
			Этот режим позволяет останавливать обмен данных на время обработки 
полученной информации.
		</p>
		<p>Рис. 8  Нуль-модемный кабель для аппаратного режима синхронизации Handshaking=2</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/006.gif" align="bottom" alt="Нуль-модемный кабель RS-232 аппаратным контролем">
		<p><strong> Модемное соединение.</strong></p>
		<p>Модемное соединение подразумевает соединение двух компьютеров(DTE) 
через модемы(DCE). 
			Модемы (модуляторы-демодуляторы) - специальные устройства, 
позволяющие вести обмен данными практически на неограниченное 
расстояния, используя для этого модуляцию и демодуляцию информационных 
сигналов. 
			Поэтому модемное соединение подразумевает подключение СОМ-порта 
компьютера(DTE) к конечному устройству модему (DCE). 
			Обычно в таком соединении используют аппаратный режим синхронизации  
Handshaking =2 (модемы - это медленные устройства). 
			Этот режим позволяет модемам управлять процессом передачи данных.
		</p>
		<p>Рис. 9  Типичный модемный кабель.</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/007.gif" align="bottom" alt="Модемный кабель RS-232">
		<br><br><br><br>
<a name="M17"></a>
		<h3>1.7 Организация обмена данных при аппаратном режиме синхронизации.</h3>
		<p>Аппаратный режим синхронизации обмена данными RTS/CTS (hardware 
flow control)  Handshaking =2, использует сервисные сигналы RS-232C для 
управления потоком данных.
		</p>
		<p>Рис.10  Организация обмена при аппаратной синхронизации.</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/008.gif" align="bottom" alt="Организация обмена при аппаратной синхронизации RS-232">
		
		<ul type="1" start="1">Порядок выставления сервисных сигналов при обмене через модем:
			<li>DTR=True  компьютер указывает на желание использовать модем
			</li><li>В ответ модем сигнализирует  о установлении соединения с другим модемом и своей готовности выставив  DSR=True.
			</li><li>Сигналом RTS=True  компьютер запрашивает разрешение на передачу и заявляет о своей готовности принимать данные от модема.
			</li><li>Сигналом CTS=True модем уведомляет о своей готовности к приему данных от компьютера и передаче их в линию. 
				По этому сигналу начинается обмен данными между терминалами через модемы.
			</li><li>Установкой CTS=False модем сигнализирует о невозможности дальнейшего приема, компьютер должен приостановить передачу данных. 
			</li><li>Установкой CTS=True, модем сообщает, что он может продолжать обмен данными.
			</li><li>Установкой RTS=False компьютер сообщает модему о временной приостановке обмена.
			</li><li>Модем получив сигнал остановки обмена RTS=False, сообщает о приостановки обмена сигналом CTS=False
			</li><li>Компьютер вновь готов принимать данные и он выставляет сигнал RTS=True
			</li><li>Модем получив сигнал от компьютера о готовности к обмену 
выставляет свою готовность CTS=True. После чего возобновляется обмен 
данных.
			</li><li>Компьютер указывает на завершение обмена выставив RTS=False
			</li><li>Модем подтверждает завершение обмена сигналом CTS=False
			</li><li>Компьютер снимает сигнал DTR, что является сообщением для модема разорвать соединение и повесить трубку.
			</li><li>Модем подтверждает разрыв соединения установкой сигнала   DSR=False
		</li></ul>
		<p>Как видно из рис.10  модем использует сигнал CTS, который позволяет
 остановить передачу данных, если приемник не готов к их приему. 
			Передатчик «выпускает» очередной байт только при включенной линии 
CTS. 
			Байт, который уже начал передаваться, задержать сигналом CTS 
невозможно (это гарантирует целостность посылки). 
			Аппаратный протокол обеспечивает самую быструю реакцию передатчика на
 состояние приемника.
		</p>
		<br><br>
<a name="M18"></a>
		<h3>1.8 Организация обмена данных при программном режиме синхронизации. </h3>
		<p>Программный протокол управления потоком XON/XOFF( Handshaking =1). 
			Работает протокол следующим образом: если устройство, принимающее 
данные, обнаруживает причины, по которым оно не может их дальше 
принимать, оно по обратному последовательному каналу посылает 
байт-символ XOFF (13hex). 
			Противоположное устройство, приняв этот символ, приостанавливает 
передачу. 
			Когда принимающее устройство снова становится готовым к приему 
данных, оно посылает символ XON (11hex), приняв который противоположное 
устройство возобновляет передачу. 
			Время реакции передатчика на изменение состояния приемника по 
сравнению с аппаратным протоколом увеличивается, по крайней мере, на 
время передачи символа (XON или XOFF) плюс время реакции программы 
передатчика на прием символа.
			Преимущество программного протокола заключается в отсутствии 
необходимости передачи управляющих сигналов интерфейса — минимальный 
кабель для двустороннего обмена может иметь только 3 провода. 
			Недостатком данного метода является большее время реагирования и 
исключения из передаваемого потока двух символов (13hex, 11hex).
		</p>
		<p>Существует смешанный метод синхронизации обмена данными 
RTS/XOn/Xoff (Handshaking =3), который представляет собой объединение 
двух предыдущих методов.
		</p>
		<br><br>
<a name="M19"></a>
		<h3>1.9 Описание контрольных битов (Parity Control Bit):</h3>
		<ul>Режимы контрольного бита (Parity Control Bit)
			<li><strong>N(None)</strong> - проверка на паритет не используется и бит не выставляется;
			</li><li><strong>E(EVEN) </strong>- проверка на четность, дополняет передаваемый символ так, чтобы количество единиц в передаваемом символе было четным;
			</li><li><strong>O(Odd)</strong>- проверка на нечетность, дополняет передаваемый символ так, чтобы количество единиц в передаваемом символе было нечетным;
			</li><li><strong>M(MARK) </strong>- бит паритета всегда равен единице;
			</li><li><strong>S(SPACE)</strong>- бит паритета всегда равен нулю.
		</li></ul>
		<br><br>
<a name="M20"></a>
		<h3>1.10 ASCII кодовая таблица.</h3>
		<p>Для кодирования символов передаваемых по RS-232С используется таблица, кодирующая использованные символы и управляющие знаки.
		</p>
		<p>Рис.11 Стандартная кодовая таблица  ASCII</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/009.gif" align="bottom" alt="ASCII 437">
		<p>Первые 32 символа этой кодовой страницы представляют собой управляющие символы, которые предназначены для управления модемом.  
			Например, использование  символов 17(11hex) и 19(13hex) были изложены выше, в программном способе управления обменом. 
			Эти символы были разработаны в основном для управления печатающими устройствами и модемами
		</p>

		<table frame="border">
        		<caption>Таблица 2. Управляющие символы ASCII. </caption>
        		<tbody><tr><td>00(00hex) - NUL пустой символ	</td><td>08(08hex)-  BS возврат на одну позицию	</td><td>16(10hex)-  DLE переключение кода			</td><td>24(18hex)-  CAN отмена
			</td></tr><tr><td>01(01hex)-  SOH	начало заголовка</td><td>09(09hex)-  HT горизонтальная табуляция	</td><td>17(11hex)-  DC1 управление первым устройством (XON)	</td><td>25(19hex)-  EM конец носителя
			</td></tr><tr><td>02(02hex)-  STX	начало текста	</td><td>10(0Ahex)-  LF перевод строки		</td><td>18(12hex)-  DC2 управление вторым устройством	</td><td>26(1Ahex)-  SUB замена
			</td></tr><tr><td>03(03hex)-  ETX	конец текста	</td><td>11(0Bhex)-  VT вертикальная табуляция	</td><td>19(13hex)-  DC3 управление третьим устройством (XOFF)	</td><td>27(1Bhex)-  ESC переход
			</td></tr><tr><td>04(04hex)-  EOT	конец передачи	</td><td>12(0Chex)-  FF подача бланка (новый лист)	</td><td>20(14hex)-  DC4 управление четвертым устройством	</td><td>28(1Chex)-  FS разделитель файла
			</td></tr><tr><td>05(05hex)-  ENQ	запрос		</td><td>13(0Dhex)-  CR возврат каретки		</td><td>21(15hex)-  NAK переспрос				</td><td>29(1Dhex)-  GS разделитель группы
			</td></tr><tr><td>06(06hex)-  ACK	подтверждение	</td><td>14(0Ehex)-  SO переход на верхний регистр	</td><td>22(16hex)-  SYN режим синхронного ожидания		</td><td>30(1Ehex)-  RS разделитель записи
			</td></tr><tr><td>07(07hex)-  BEL	звонок		</td><td>15(0Fhex)-  SI переход на нижний регистр	</td><td>23(17hex)-  ETB конец передачи блока		</td><td>31(1Fhex)-  US разделитель блока
		</td></tr></tbody></table>
<a name="M21"></a>
		<h3>1.11 Аппаратная реализация СОМ портов.</h3>
		<p>Для аппаратной реализации СОМ портов по стандарту RS-232 
используется специализированная микросхема UART.
			UART (Universal Asynchronous Receiver-Transmitter  )- универсальный 
асинхронный приёмо-передатчик.
			Микросхема i8250 установленная в IBM XT послужила началом целой серии
 микросхем UART, которые устанавливались на материнские платы PC.
		</p>
			<ul>Микросхемы UART:
				<li>8250 - буфер 1 байт
				</li><li>16450 - буфер 8 байт
				</li><li>16550 - буфер 16 байт
				</li><li>16650 - буфер 32 байт
				</li><li>16750 - буфер 64 байт
				</li><li>16850 - буфер 128 байт
				</li><li>16950 - буфер 512 байт
				</li><li>Hayes ESP - буфер 1024 байт
			</li></ul>
		<p>Микросхемы выпускались разными фирмами производителями: Intel, National Semiconductor, Maxim   и др.
		</p>
		<p>
		Микросхема представляет собой управляемую логическую схему с буферными
 регистрами для приёма и передачи последовательных данных.
			Буферные регистры позволяют вести передачу и приём данных без участия
 CPU.
			Соответственно чем больше ёмкость буферных регистров, тем реже 
микросхема прерывает работу CPU.
			Буферные регистры устроены по принципу "очереди" (FIFO) - первым 
пришел, первым вышел.
			Получив порцию данных в передающий буферный регистр,  UART начинает 
передавать её в сеть RS-232, одновременно он может принимать данные из 
сети RS-232 в приёмный буферный регистр.
			Программное обеспечение в любой момент может обратиться к приёмному 
буферу UART, тем самым освободив его для приёма следующих данных.
			При заполнении приёмного буфера UART может прервать работу CPU, 
сообщив ему о заполнении буфера.
			Заполнение приёмного буфера вызовет остановку приёма данных из сети 
RS-232, до тех пор пока он не будет прочитан.<br>
			Рассмотрим работу UART на примере микросхемы PC16550D
		</p>	
					
		
		<p>Рис.12 Стандартная схема включения UART PC16550D с микропроцессором Intel 8088</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/16550.gif" align="bottom" alt="PC16550D">
		<p>Обращение к микросхеме осуществляется через адресное пространство 
портов ввода-вывода CPU.
			Микросхема подключается к системной шине при активизации сигнала CS0,
 который вырабатывается при обращении CPU к заданному диапазону адресов 
порта.
			Адреса портов ввода-вывода заданы в BIOS. Обычно они имеют значения: 
COM1=3F8h, COM2=2F8h, COM3=3E8h, COM4=2E8h .
			На входы UART  A0,A1,A2 подаются три младших разряда адресной шины 
CPU. 
			Адрес заданный в BIOS является начальным адресом диапазона адресов 
(A2A1A0=000).
			Следовательно полный диапазон адресов для каждого порта равен 8 
адресам (от A2A1A0=000 до A2A1A0=111).
			Например, для СОМ4 2E8h,2E9h,2EAh,2EBh,2ECh,2EDh,2EEh,2EFh.<br>
			Расстояние между начальными адресами портов равно 16, что допускает в
 дальнейшем использования микросхем с четырьмя начальными адресными 
линиями.
			Обращение к микросхеме по определённому адресу открывает доступ к 
группе регистров управления или буферных регистров приёма и передачи.
			CPU может записать данные в регистры UART выставив сигнал WR=0, или 
прочитать данные,  выставив сигнал RD=0.
			

			

		</p>
<a name="M22"></a>
		<h3>1.12 Программная реализация UART.</h3>
		<p>UART состоит из 12 регистров, к которым можно обратиться по восьми адресам портов ввода-вывода.<br>
			Так как индивидуального адреса для каждого регистра не хватает, то 
используют расщепление адресного пространства с помощью следующих 
методов:<br>
			
			&nbsp; &nbsp; 1.Разделение одного адресного пространства на два регистра по записи/чтению.<br>
				&nbsp; &nbsp; &nbsp; &nbsp; По сигналу чтения RD=0 читается один 
регистр, по сигналу записи WR=0 записывается второй регистр.<br>
				&nbsp; &nbsp; &nbsp; &nbsp; То есть данные по одинаковому адресу записываются или читаются с разных регистров.<br>

				&nbsp; &nbsp; &nbsp; &nbsp; Таких регистров четыре:<br>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; THR, RBR - по адресу UART 00h(A2A1A0=000)<br>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; IIR, FOR - по адресу UART 02h(A2A1A0=010)<br>
				&nbsp; &nbsp; &nbsp; &nbsp; Эти регистры односторонние, то есть в 
одни можно только записывать, в другие только читать данные.<br>
			&nbsp; &nbsp; 2.Использование дополнительного адресного бита<br>
					&nbsp; &nbsp; &nbsp; &nbsp; Используют 7-ой бит регистра LCR-находящегося по адресу UART 03h(A2A1A0=011).<br>
					&nbsp; &nbsp; &nbsp; &nbsp; Этот бит называют DLAB, если DLAB=0, то для чтения/записи используется один регистр,<br>
				 	&nbsp; &nbsp; &nbsp; &nbsp; если DLAB=1, то для чтения/записи используется второй регистр.<br>
					&nbsp; &nbsp; &nbsp; &nbsp; Таких регистров пять: <br>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (THR &amp; RBR),DLL - по адресу UART 00h(A2A1A0=000)<br>
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DIM, IER - по адресу UART 01h(A2A1A0=001)<br>
		</p>
		
		<table frame="border">
        		<caption>Таблица 3. Регистры UART.</caption>
        		<tbody><tr><td>адрес	</td><td>DLAB</td><td>чтение/запись</td><td>Название регистра
			</td></tr><tr><td>00h</td><td>0</td><td>WR</td><td>THR(Transmit Holding Register)-регистр данных ожидающих передачи
			</td></tr><tr><td>00h</td><td>0</td><td>RD</td><td>RBR(Receiver Buffer Register)- буферный регистр приемника 
			</td></tr><tr><td>00h</td><td>1</td><td>RD/WR</td><td>DLL(Divisor Latch LSB)-младший байт делителя частоты
			</td></tr><tr><td>01h</td><td>1</td><td>RD/WR</td><td>DIM(Divisor Latch MSB)-старший байт делителя частоты
			</td></tr><tr><td>01h</td><td>0</td><td>RD/WR</td><td>IER(Interrupt Enable Register)-регистр разрешения прерывания
			</td></tr><tr><td>02h</td><td>х</td><td>RD</td><td>IIR(Interrupt Identification Register)-регистр идентифицирующий прерывания
			</td></tr><tr><td>02h</td><td>х</td><td>WR</td><td>FCR(FIFO Control Register)-регистр управления режимом FIFO
			</td></tr><tr><td>03h</td><td>x</td><td>RD/WR</td><td>LCR(Line Control Register)-регистр управления линией связи
			</td></tr><tr><td>04h</td><td>x</td><td>RD/WR</td><td>MCR(Modem Control Register)-регистр управления модемом
			</td></tr><tr><td>05h</td><td>x</td><td>RD/WR</td><td>LSR(Line Status Register)-регистр состояния линии связи
			</td></tr><tr><td>06h</td><td>x</td><td>RD/WR</td><td>MSR(Modem Status Register)-регистр состояния модема
			</td></tr><tr><td>07h</td><td>x</td><td>RD/WR</td><td>SCR(Scratch Pad Register)-регистр временного хранения

		</td></tr></tbody></table>
		<p>Рис.13 Функциональная схема UART PC16550.</p>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_16.gif" align="bottom" alt="UART PC16550">
		<p style="font-size : 18pt ; font-style : italic; color : indigo">THR-регистр данных ожидающих передачи(только для записи)<br>
			(Transmit Holding Register)
		</p>
		Рис.14 Регистр THR  (Адрес=00h, DLAB=0, WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_17.gif" align="bottom" alt="THR UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; В этот регистр записывают байт данных, 
определённый как символ (от 5 до 8 бит) который будет передан в линию 
связи.
			Символ, принятый в THR передаётся далее в сдвигающий регистр младшем 
битом вперед (см. рис.5). 
			В начало символа добавляется стартовый бит, в конец символа 
добавляется стоповый бит.
			Перед стоповым битом может находиться бит паритета.
			Если символ короче 8 бит, то старшие биты регистра THR игнорируются 
(не используются, хотя записываются в этот регистр).
			Регистр THR может принять всего один байт данных и передать его в 
регистр последовательного сдвига.
			В большинстве UART имеется режим FIFO, в котором данные загружаются 
не в THR, а в регистр FIFO.
			Например, UART PC16550 имеет регистр FIFO, который может принять 16 
байт данных.
			Кроме этого у некоторых UART существует режим DMA, в этом режиме 
сдвигающий регистр заполняется байтами данных непосредственно из 
оперативной памяти без участия микропроцессора.<br>
			Для указания того, что регистр THR пуст и в него можно загрузить 
очередной байт данных используют бит 5 регистра LSR.
			Этот бит называется THRE(Transmitter Holding Register Empty) 
-"регистр данных ожидающих передачи пуст".
			Если THRE=1, то в регистр THR можно посылать очередной байт данных, в
 режиме FIFO этот бит говорит о том, что регистр FIFO пуст и можно 
посылать следующий пакет байтов данных.
			Бит THRE может быть источником прерывания CPU. 
	
		</p>
		<p style="font-size : 18pt ; font-style : italic; color : indigo">RBR- буферный регистр приемника(только для чтения)<br>
		(Receiver Buffer Register)
		</p>
		Рис.15 Регистр RBR  (Адрес=00h, DLAB=0, RD)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_17.gif" align="bottom" alt="THR UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; В этот регистр байты(символы) 
принимаются из приемного сдвигающегося регистра.
			Регистр RBR может принять только один байт из сдвигающего приемного 
регистра.
			Аналогично передающей части UART здесь есть регистр FIFO, который 
может принимать больше одного байта данных минуя регистр RBR.
			К моменту заполнения сдвигающего приёмного регистра регистр RBR 
должен быть освобожден для приема очередного байта, иначе произойдет 
ошибка переполнения.
			Освобождение регистра RBR происходит, когда данные из него читаются 
микропроцессором.
			О том, что символ потерян в результате переполнения сообщает бит 1 
регистра LSR.
			Этот бит называется ОЕ (Overrun Error)-"ошибка переполнения", OE=1 
означает что один из переданных символов потерян.<br>
			О том, что байт готов к прочтению микропроцессором (т.е. полностью 
выгрузился из приемного сдвигающегося регистра или FIFO) сообщает  бит 0
 регистра LSR.
			Этот бит называется DR (Receiver Data Ready) -"Данные приёмника 
готовы".
			DR=1 говорит о том, что регистр RBR(или FIFO) содержит принятый байт и
 его необходимо прочитать, DR сбрасывается в ноль после прочтения 
регистра RBR микропроцессором.
			Это бит также может инициировать прерывание микропроцессора.

		</p>
		<p style="font-size : 18pt ; font-style : italic; color : indigo">DLL-младший байт делителя частоты :16 (чтение/запись)<br>
			(Divisor Latch LSB)
		</p>
		Рис.16 Регистр RBR  (Адрес=00h, DLAB=1, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_17.gif" align="bottom" alt="DLL register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; В это регистре находится младший байт делителя частоты деленного на 16.
		</p>
		<p style="font-size : 18pt ; font-style : italic; color : indigo">DIM-старший байт делителя частоты :16 (чтение/запись)<br>
			(Divisor Latch MSB)
		</p>
		Рис.17 Регистр RBR  (Адрес=01h, DLAB=1, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_17.gif" align="bottom" alt="DIM register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; В этом регистре находится старший байт делителя частоты деленного на 16.<br>
		В микросхеме UART частота задающего кварца делится на делитель 
частоты(Decimal Divisor),который получается из двухбайтового числа 
(DIM,DLL) умноженного на 16.
		Таким образом делитель частоты задает скорость обмена данных через 
UART.<br>
		Записью в регистры DIM и DLL старшего и младшего байта этого 
двухбайтового числа вы зададите скорость обмена СОМ-порта в бит/сек.<br>
		Для кварца UART частотой f=1,8432 МГц, делитель частоты:16 считается по формуле:<br>
		</p><p style="font-size : 18pt ;  color : green">D=115200/V<small>, где V-скорость в бит/сек, D=делитель частоты:16</small></p>
		Для кварца UART частотой f=24 МГц, делитель частоты:16 считается по формуле:<br>
		<p style="font-size : 18pt ;  color : green">D=1 500 000/V<small>, где V-скорость в бит/сек, D=делитель частоты:16</small></p>
		<table frame="border">
        		<caption>Таблица 4. Делитель частоты для UART PC16550.</caption>
			<tbody><tr><th></th><th colspan="3">1,8432 МГц</th><th colspan="3">24 МГц
        		</th></tr><tr><td>Скорость, бит/сек</td><td>делитель:16</td><td>DIM</td><td>DLL</td><td>делитель:16</td><td>DIM</td><td>DLL
			</td></tr><tr><td>50</td><td>2304</td><td>09h</td><td>00h</td><td>30000</td><td>75h</td><td>30h
			</td></tr><tr><td>75</td><td>1536</td><td>06h</td><td>00h</td><td>20000</td><td>4Eh</td><td>20h
			</td></tr><tr><td>110</td><td>1047</td><td>41h</td><td>07h</td><td>13636</td><td>35h</td><td>44h
			</td></tr><tr><td>150</td><td>768</td><td>03h</td><td>00h</td><td>10000</td><td>27h</td><td>10h
			</td></tr><tr><td>300</td><td>384</td><td>01h</td><td>80h</td><td>5000</td><td>13h</td><td>88h
			</td></tr><tr><td>600</td><td>192</td><td>00h</td><td>C0h</td><td>2500</td><td>09h</td><td>C4h
			</td></tr><tr><td>1 200</td><td>96</td><td>00h</td><td>60h</td><td>1250</td><td>04h</td><td>E2h
			</td></tr><tr><td>1 800</td><td>64</td><td>00h</td><td>40h</td><td>833</td><td>03h</td><td>41h
			</td></tr><tr><td>2 000</td><td>58</td><td>00h</td><td>3Ah</td><td>750</td><td>02h</td><td>EEh
			</td></tr><tr><td>2 400</td><td>48</td><td>00h</td><td>30h</td><td>625</td><td>02h</td><td>71h
			</td></tr><tr><td>3 600</td><td>32</td><td>00h</td><td>20h</td><td>417</td><td>0h</td><td>A1h
			</td></tr><tr><td>4 800</td><td>24</td><td>00h</td><td>18h</td><td>312</td><td>01h</td><td>38h
			</td></tr><tr><td>7 200</td><td>16</td><td>00h</td><td>10h</td><td>208</td><td>00h</td><td>D0h
			</td></tr><tr><td>9 600</td><td>12</td><td>00h</td><td>0Ch</td><td>156</td><td>00h</td><td>9Ch
			</td></tr><tr><td>14 400</td><td>8</td><td>00h</td><td>08h</td><td>104</td><td>00h</td><td>68h
			</td></tr><tr><td>19 200</td><td>6</td><td>00h</td><td>06h</td><td>78</td><td>00h</td><td>4Eh
			</td></tr><tr><td>28 800</td><td>4</td><td>00h</td><td>04h</td><td>52</td><td>00h</td><td>34h
			</td></tr><tr><td>38 400</td><td>3</td><td>00h</td><td>03h</td><td>39</td><td>00h</td><td>27h
			</td></tr><tr><td>57 600</td><td>2</td><td>00h</td><td>02h</td><td>26</td><td>00h</td><td>1Ah
			</td></tr><tr><td>115 200</td><td>1</td><td>00h</td><td>01h</td><td>13</td><td>00h</td><td>0Dh
			</td></tr><tr><td>250 000</td><td>x</td><td>x</td><td>x</td><td>6</td><td>00h</td><td>06h
			</td></tr><tr><td>300 000</td><td>x</td><td>x</td><td>x</td><td>5</td><td>00h</td><td>05h
			</td></tr><tr><td>375 000</td><td>x</td><td>x</td><td>x</td><td>4</td><td>00h</td><td>04h
			</td></tr><tr><td>500 000</td><td>x</td><td>x</td><td>x</td><td>3</td><td>00h</td><td>03h
			</td></tr><tr><td>750 000</td><td>x</td><td>x</td><td>x</td><td>2</td><td>00h</td><td>02h
			</td></tr><tr><td>1 500 000</td><td>x</td><td>x</td><td>x</td><td>1</td><td>00h</td><td>01h

		</td></tr></tbody></table><br>
		Как видно из таблицы 4, СОМ порт ПК (с UART 16550 и выше) может работать на скорости до 1,5Mb/s.
		
		<p></p>
		<p style="font-size : 18pt ; font-style : italic; color : indigo">IER-регистр разрешения прерывания(чтение/запись)<br>
			(Interrupt Enable Register)
		</p>
		Рис.18 Регистр IER  (Адрес=01h, DLAB=0, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_20.gif" align="bottom" alt="IER register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Регистр разрешения прерываний дает 
разрешения определённым событиям вызывать прерывание микропроцессора.<br>
		Бит 0.  <big><strong>RxD_IЕ</strong></big> — если RxD_IЕ=1,то 
разрешено прерывание для приема данных,это прерывание возникает когда  
необходимо принять символ из регистра RBR (в режиме FIFO — прерывание по
 тайм-ауту).<br><br>
		
		Бит 1.  <big><strong>TxD_IE</strong></big> — если TxD_IEЕ=1,то 
разрешено прерывание для передачи данных, это прерывание возникает когда
  передающий буфер пуст и необходимо загрузить байт в регистр THR.<br><br>

		Бит 2.  <big><strong>RxL_IЕ</strong></big> — если RxL_IЕ=1,то 
разрешено прерывание при обрыве линии связи или ошибке в приёме данных, 
это прерывание возникает когда в регистре состояния линии связи  LSR 
будут выставлены биты этих ошибок.<br><br>

		Бит 3.  <big><strong>Mod_IЕ </strong></big> — если Mod_IЕ =1,то 
разрешено прерывание при изменении состояния любого из входных сигналов 
RST,CTS,DCD,RI, это прерывание возникает когда состояние входных 
сигналов COM-порта изменились.<br><br>	
		Бит 4..7. Не используются и всегда равны 0.

		
		</p>

		<p style="font-size : 18pt ; font-style : italic; color : indigo">IIR-регистр идентифицирующий прерывания (чтение)<br>
			(Interrupt Identification Register)
		</p>
		Рис.19 Регистр IIR  (Адрес=02h, RD)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_21.gif" align="bottom" alt="IIR register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Чтобы минимизировать программное 
обеспечение, UART располагает по приоритетам прерывания в четыре уровня и
 делает запись этих прерываний в IIR. 
			Четыре уровня прерывания располагаются  в порядке приоритета условий 
прерывания заданных регистрами - RLS; RDR; THR; и MSR.
			Когда CPU обращается к IIR, UART замораживает все прерывания и 
указывает самое высокое приоритетное отложенное прерывание для CPU. 
			Во время обработки прерывания,  UART делает запись новых прерываний, 
но не изменяет их текущий признак, до полной обработки. <br><br>
		Бит 0.  <big><strong>IP</strong></big>(Interrupt Pending)— если IP=1, то все прерывания обработаны. Если IP=0,то есть необработанные прерывания. <br><br>
		
		Бит 1.  <big><strong>I_ID0</strong></big>(Interrupt ID Bit0)- нулевой бит идентификатора прерываний<br>

		Бит 2.  <big><strong>I_ID1</strong></big>(Interrupt ID Bit1)- первый бит идентификатора прерываний<br>

		Бит 3.  <big><strong>I_ID2</strong></big>(Interrupt ID Bit2)- второй бит идентификатора прерываний<br>	

		<table frame="border">
        		<caption>Таблица 5. Идентификация прерывания (обычный режим)</caption>
			
			<tbody><tr><td>I_ID2</td><td>I_ID1</td><td>I_ID0</td><td>Приоритет</td><td>идентификация
			</td></tr><tr><td>x</td><td>0</td><td>0</td><td>Четвертый</td><td>Изменилось состояние модема, сбрасывается прочтением регистра MSR.
			</td></tr><tr><td>x</td><td>0</td><td>1</td><td>Третий</td><td>Регистр THR пуск, ожидается байт от CPU. Сбрасывается записью байта в THR.
			</td></tr><tr><td>x</td><td>1</td><td>0</td><td>Второй</td><td>Принят байт данных в регистр RBR, сбрасывается чтением регистра RBR.
			</td></tr><tr><td>x</td><td>1</td><td>1</td><td>Наивысший</td><td>Обрыв линии или ошибка на линии, сбрасывается прочтением регистра LSR.
		</td></tr></tbody></table><br>

		<table frame="border">
        		<caption>Таблица 6. Идентификация прерывания (режим FIFO)</caption>
			
			<tbody><tr><td>I_ID2</td><td>I_ID1</td><td>I_ID0</td><td>Прирритет</td><td>идентификация
			</td></tr><tr><td>0</td><td>0</td><td>0</td><td>Четвертый</td><td>Изменилось состояние модема, сбрасывается прочтением регистра MSR
			</td></tr><tr><td>0</td><td>0</td><td>1</td><td>Третий</td><td>Буферный регистр передачи FIFO пуск, ожидается данные от CPU. Сбрасывается записью  в передающий буфер FIFO
			</td></tr><tr><td>0</td><td>1</td><td>0</td><td>Второй</td><td>Приемный буфер FIFO заполнился, сбрасывается чтением приемного буфера FIFO.
			</td></tr><tr><td>0</td><td>1</td><td>1</td><td>Наивысший</td><td>Обрыв линии или ошибка на линии, сбрасывается прочтением регистра LSR
			</td></tr><tr><td>1</td><td>0</td><td>0</td><td></td><td>
			</td></tr><tr><td>1</td><td>0</td><td>1</td><td></td><td>
			</td></tr><tr><td>1</td><td>1</td><td>0</td><td>Второй</td><td>индикатор
 тайм-аута (за 4-кратный интервал времени символа не передано и не 
принято ни одного символа, хотя в буфере FIFO имеется, по крайней мере, 
один символ). Сброс выполняется чтением приемного буфера FIFO.
			</td></tr><tr><td>1</td><td>1</td><td>1</td><td></td><td>


		</td></tr></tbody></table><br>
		Бит 4..5.Зарезервированны<br><br>
		
		Бит 6.  <big><strong>FE_ID0</strong></big>(FIFOs Enabled ID Bit0)- нулевой бит идентификатора режима FIFO<br>
		Бит 7.  <big><strong>FE_ID1</strong></big>(FIFOs Enabled ID Bit1)- первый бит идентификатора режима FIFO<br>
		<table frame="border">
        		<caption>Таблица 7. Идентификация режима FIFO</caption>
			
			<tbody><tr><td>FE_ID1</td><td>FE_ID0</td><td>Режим
			
			</td></tr><tr><td>0</td><td>0</td><td>обычный режим работы, данные передаются побайтно через регистры THR и RBR.
			</td></tr><tr><td>0</td><td>1</td><td>
			</td></tr><tr><td>1</td><td>0</td><td>режим FIFO для UART  16550.
			</td></tr><tr><td>1</td><td>1</td><td>режим FIFO для UART  16550A.
		</td></tr></tbody></table><br><br>
		

		</p><p style="font-size : 18pt ; font-style : italic; color : indigo">FCR-регистр управления режимом FIFO (запись)<br>
			(FIFO Control Register)
		</p>
		Рис.20 Регистр FCR  (Адрес=02h, WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_22.gif" align="bottom" alt="FCR register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Это регистр используется только для 
записи, его данные расположены как в регистре  IIR. 
			Этот регистр используется, чтобы разрешить режимы FIFO, очистить 
буферы FIFO, задать уровень заполнения буферов FIFO, и выбрать тип 
DMA(прямого обращения к памяти).<br><br>

		Бит 0.  <big><strong>TRFIFOE</strong></big>(Transmit And Receive FIFO Enable)— Запись 1 в этот бит допускает оба режима FIFO передатчика(XMIT) и приемника(RCVR). 
												Сброс бита в 0 очистит все байты в обоих буферов FIFO.
												При изменении режима FIFO к 16450 и наоборот, буферы FIFO автоматически очищаются. 
												Этот бит должен быть в 1, когда производится запись других битов регистра FCR, иначе они не будут запрограммированы.<br><br>
		
		Бит 1.  <big><strong>RESETRF</strong></big>(Reset Receiver FIFO)-Запись 1 в этот бит очищает все байты в приемном буфере FIFO и сбрасывает его счетчик в  0. 
										Сдвиговый регистр при этом  не очищается. 
										После этого 1 в этом бите сбрасывается в 0.<br><br>

		Бит 2.  <big><strong>RESETTF</strong></big>(Reset Transmitter FIFO)- Запись 1 в этот бит очищает все байты в передающем буфере FIFO и сбрасывает его счетчик в  0. 
										Сдвиговый регистр при этом  не очищается. 
										После этого 1 в этом бите сбрасывается в 0.<br><br>

		Бит 3.  <big><strong>DMAE</strong></big>(DMA Enabled)- Запись 1 в этот бит приводит к изменению сигналов  UART RxRDY и TxRDY с 0 к 1,при условии что FCR(bit0)=1.
										Эти аппаратные сигналы используются для организации правильной работы режима DMA в микропроцессорной системе.<br><br>	

		
		Бит 4..5.Зарезервированные.<br><br>
		
		Бит 6.  <big><strong>ITL_ID0</strong></big> (Interrupt Trigger Level ID bit0) - нулевой бит идентификатора триггера уровня прерывания.<br>
		Бит 7.  <big><strong>ITL_ID1</strong></big>(Interrupt Trigger Level ID bit1)- первый бит идентификатора триггера уровня прерывания.<br>
		В этих двух битах задается идентификатор,  который задает уровень при 
котором будет вырабатываться прерывание при приеме данных в режиме FIFO.
 Уровень задается количеством байт в приемном(RCVR) буфере FIFO. <br>
		<table frame="border">
        		<caption>Таблица 8. Идентификация тригера уровня прерывания</caption>
			
			<tbody><tr><td>ITL_ID1</td><td>ITL_ID0</td><td>уровень прерывания, байт
			</td></tr><tr><td>0</td><td>0</td><td>01
			</td></tr><tr><td>0</td><td>1</td><td>04
			</td></tr><tr><td>1</td><td>0</td><td>08
			</td></tr><tr><td>1</td><td>1</td><td>14
		</td></tr></tbody></table><br><br>
		</p>


		<p style="font-size : 18pt ; font-style : italic; color : indigo">LCR-регистр управления линией связи(запись/чтение)<br>
			(Line Control Register)
		</p>
		Рис.21 Регистр LCR  (Адрес=03h, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_23.gif" align="bottom" alt="LCR register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Данный регистр служит для 
определения(задания) формата асинхронного обмена передачи данных.
					Также в этом режиме устанавливается бит DLAB, который позволяет 
программисту записывать и читать данные из нужных регистров..
					Программист может не только записывать, но и читать содержимое 
регистра LCR. 
					Способность чтения упрощает системное программирование и устраняет 
потребность в отдельной области в системной памяти для хранения 
характеристик линии. <br><br>

		Бит 0.  <big><strong>SDB_ID0</strong></big>(Serial Data Bits ID0)- нулевой бит идентификатора количества бит в передаваемом символе.<br>
		
		Бит 1.  <big><strong>SDB_ID1</strong></big>(Serial Data Bits ID1)- первый бит идентификатора количества бит в передаваемом символе.<br>
		С помощью этих битов задают количество бит в передаваемом или принимаемом символе.<br><br>
		<table frame="border">
        		<caption>Таблица 9. Количество бит в символе данных</caption>
			
			<tbody><tr><td>SDB_ID1</td><td>SDB_ID0</td><td>количество бит в символе
			</td></tr><tr><td>0</td><td>0</td><td>5
			</td></tr><tr><td>0</td><td>1</td><td>6
			</td></tr><tr><td>1</td><td>0</td><td>7
			</td></tr><tr><td>1</td><td>1</td><td>8
		</td></tr></tbody></table><br>

		Бит 2.  <big><strong>STOP_B</strong></big>(Stop Bits)- Этот бит 
определяет число стоповых битов, переданных или полученных в каждом 
последовательном символе. 
									Если бит STOP_B=0, то передается один стоповый бит. Если бит 
STOP_B=1, то стоповый бит равен двум для 6,7,8 битовых символов и 
полтора стоповых бита для 5-ти битовых символов. 
									Приемник проверяет только первый стоповый бит, независимо от 
выставленных стоповых битов.<br><br>

		Бит 3.  <big><strong>PAREN</strong></big>(Parity Enable) -Если 
PAREN=1, то разрешено использование бита паритета и данный бит 
вставляется между последним битом данных и стоповым битом. Если PAREN=0,
 то бит паритета не выставляется и не входит в состав передаваемого 
символа.<br><br>	

		Бит 4.  <big><strong>EVENPAR</strong></big>(Even Parity Select)  - Бит
 выбора типа контроля паритета. Если EVENPAR=1, то происходит проверка 
на четность. Если EVENPAR=0, то происходит проверка на нечетность.<br><br>	
		
		Бит 5.  <big><strong>STICPAR</strong></big> (Sticky Parity)- Если STICPAR=0, то бит паритета бит генерируется в соответствии с паритетом выводимого символа.
										Если STICPAR=1, то постоянное значение контрольного бита: при EVENPAR=1 — нулевое, при EVENPAR=0 — единичное. <br><br>	
		
		Бит 6.  <big><strong>BRCON</strong></big>(Break Control)- Управляющий 
бит обрыва связи. Если BRCON=1, то вслучае возникновения перерыва в 
приеме данных, передатчик UART начнёт передавать в линию нули. <br><br>


		Бит 7.  <big><strong>DLAB</strong></big>(Divisor Latch Access Bit)- 
Этот бит доступа к делителю частоты. Если DLAB=1, то можно обратиться к 
регистрам DIM, DLL в которых хранятся младший и старший байт делителя 
частоты :16.Если DLAB=0, то можно обратиться к регистрам THR,RBR,IER.<br><br>
				
		</p>


		<p style="font-size : 18pt ; font-style : italic; color : indigo">MCR-регистр управления модемом (запись/чтение)<br>
			(Modem Control Register)
		</p>
		Рис.22 Регистр MCR  (Адрес=04h, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_24.gif" align="bottom" alt="MCR register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Этот регистр управляет интерфейсом модема  или периферийным устройством. <br><br>

		Бит 0.  <big><strong>DTR</strong></big>(Serial Data Bits ID0)(Data Terminal Ready)- Этот бит управляет выходным сигналом DTR (Готовность терминала данных).<br>
								Когда бит DTR=1, вывод DTR UART устанавливается в логический  0,
 в IBM XT этот сигнал инвертируется буферным инвертором 
DS1488(см.рис.12) в логическую 1 т.е. U= +12в (сигнал DTR COM-порта 
считается включенным)<br>
								Соответственно когда бит DTR=0, сигнал DTR COM-порта U= -12в логический 0 (сигнал DTR считается выключенным)<br><br>

		
		Бит 1.  <big><strong>RTS</strong></big>(Request To Send )- Этот бит управляет выходным сигналом RTS (Запрос на передачу).<br>
								Когда бит RTS=1, вывод RTS UART устанавливается в логический  0,
 в IBM XT этот сигнал инвертируется буферным инвертором 
DS1488(см.рис.15) в логическую 1 т.е. U= +12в (сигнал RTS COM-порта 
считается включенным)<br>
								Соответственно когда бит RTS=0, сигнал RTS COM-порта U= -12в логический 0 (сигнал RTS считается выключенным)<br><br>
		

		Бит 2.  <big><strong>OUT1</strong></big>(OUT1 Bit Control) - Управление вспомогательным выходом OUT1.<br><br>

		Бит 3.  <big><strong>OUT2</strong></big>(OUT2 Bit Control) - Управление вспомогательным выходом OUT2.<br><br>

		Бит 4.  <big><strong>LOOP</strong></big>(Loopback Mode Enable)-Бит 
режима диагностики. Если LOOP=0, то UART работает в обычном режиме. Если
 LOOP=1, то URAT работет в режиме диагностики с обратной связью, в этом 
режиме используются вспомогательные сигналы OUT1 и OUT2.<br><br>	
		
		Бит 5..7. Зарезервированы. <br><br>	
		
		
				
		</p>


		
		<p style="font-size : 18pt ; font-style : italic; color : indigo">LSR	-регистр состояния линии связи (запись/чтение)<br>
			(Line Status Register)
		</p>
		Рис.23 Регистр LSR  (Адрес=05h, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_25.gif" align="bottom" alt="LSR register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Данный регистр показывает состояние приемопередатчика. <br><br>

		Бит 0.  <big><strong>DR</strong></big>(Receiver Data Ready) — 
Готовность данных приемника.DR=1 информирует о том, что данные приняты и
 загружены в регистр RBR или приемный буфер FIFO.
										Бит сбрасывается в ноль, когда все данные будут прочитаны CPU 
из регистра RBR или буфера FIFO.<br><br>

		
		Бит 1.  <big><strong>OE</strong></big>(Overrun Error) — Бит ошибки 
переполнения. Бит  указывает, что данные в регистре RBR не были 
прочитаны CPU прежде, чем следующий символ был передан в RBR, что 
привело к потере предыдущего символа. 
										Бит устанавливается в OE=1 после обнаружения ошибки 
переполнения и сбрасывать всякий раз, когда SPU читает содержание 
регистра LSR.<br><br>
		

		Бит 2.  <big><strong>PE</strong></big>(Parity Error) —Бит ошибки контрольного бита паритета.PE=1 если символ принят с ошибкой паритета.<br><br>

		Бит 3.  <big><strong>FE</strong></big>(Framing Error) — ошибка кадра (неверный стопбит).<br><br>

		Бит 4.  <big><strong>BD</strong></big>(Break Detected) — индикатор обрыва линии (вход приемника находится в состоянии 0 не менее чем время посылки символа).<br><br>	
		
		Бит 5.  <big><strong>THRE</strong></big>(Transmitter Holding Register 
Empty) — регистр передатчика готов принять байт для передачи. В режиме 
FIFO указывает на отсутствие символов в FIFO-буфере передачи. Может 
являться источником прерывания.<br><br>	
		
		Бит 6.  <big><strong>TEMPT</strong></big>(Transmitter Empty Status) — 
регистр передатчика пуст (нет данных для передачи ни в сдвиговом 
регистре, ни в буферных регистрах THR или FIFO).<br><br>	

		Бит 7.  <big><strong>FIFOE</strong></big>(FIFO Error Status) —ошибка 
принятых данных в режиме FIFO (буфер содержит хотя бы один символ, 
принятый с ошибкой формата, паритета или обрывом). В не FIFO-режиме 
всегда 0.<br><br>	
				
		</p>



		<p style="font-size : 18pt ; font-style : italic; color : indigo">MSR-регистр состояния модема <br>
			(Modem Status Register)
		</p>
		Рис.24 Регистр MSR  (Адрес=06h, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_26.gif" align="bottom" alt="MSR register UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Этот регистр позволяет CPU 
контролировать текущее состояние линий управления модема или 
периферийного устройства. 
						В дополнение к этому , четыре бита (0..3)  регистра MSR 
контролируют изменения сигналов на входах CTS,RTS,RI,DCD микросхемы и 
вырабатывают прерывание микропроцессора. <br><br>

		Бит 0.  <big><strong>DCTS</strong></big>(Delta Clear To Send) — 
Изменение состояния сигнала CTS(очищен для передачи).Бит устанавливается
 в DCTS=1 при изменении сигнала CTS на входе микросхемы и сбрасывается 
при прочтении регистра MSR микропроцессором.
						При установке бита в 1 генерируется прерывание микропроцессора.<br><br>

		
		Бит 1.  <big><strong>DDSR</strong></big>(Delta Data Set Ready) — 
Изменение состояния сигнала DSR(установка данных готова).Бит 
устанавливается в DDSR=1 при изменении сигнала DSR на входе микросхемы и
 сбрасывается при прочтении регистра MSR микропроцессором.
									При установке бита в 1 генерируется прерывание микропроцессора.<br><br>
		

		Бит 2.  <big><strong>ТЕRI</strong></big>(Trailing Edge Of Ring 
Indicator) — Детектор заднего фронта сигнала RI(индикатор звонка).  Бит 
устанавливается в TERI=1, когда сигнал на выводе микросхемы RI изменяет 
свой уровень с низкого на высокий.  Бит сбрасывается в TERI=0 при 
прочтении регистра MSR микропроцессором.
									При установке бита в 1 генерируется прерывание микропроцессора.<br><br>

		Бит 3.  <big><strong>DDCD</strong></big>(Delta Data Carrier Detect) — 
Изменение состояния сигнала DCD(обнаружен носитель информации).Бит 
устанавливается в DDCD=1 при изменении сигнала DCD на входе микросхемы и
 сбрасывается при прочтении регистра MSR микропроцессором.
									При установке бита в 1 генерируется прерывание микропроцессора.<br><br>

		Бит 4.  <big><strong>CTS</strong></big>(Clear To Send) — Состояние 
линии CTS.  Если CTS=1, то на вход CTS СОМ-порта подано напряжение 
+12в(сигнал CTS активен).Если CTS=0, то вход СОМ-порта подано напряжение
 -12В(сигнал CTS пассивен).
										В режиме диагностики этот бит эквивалентен биту RTS регистра 
MCR.<br><br>	
		
		Бит 5.  <big><strong>DSR</strong></big>(Data Set Ready) — Состояние 
линии DSR.  Если DSR=1, то на вход DSR СОМ-порта подано напряжение 
+12в(сигнал DSR активен).Если DSR=0, то вход СОМ-порта подано напряжение
 -12В(сигнал DSR пассивен).
									В режиме диагностики этот бит эквивалентен биту DTR регистра 
MCR.<br><br>		
		
		Бит 6.  <big><strong>RI</strong></big>(Ring Indicator) — Состояние 
линии RI.  Если RI=1, то на вход DSR СОМ-порта подано напряжение 
+12в(сигнал RI активен).Если RI=0, то вход СОМ-порта подано напряжение 
-12В(сигнал RI пассивен).
									В режиме диагностики этот бит эквивалентен биту OUT1 регистра 
MCR.<br><br>		

		Бит 7.  <big><strong>DCD</strong></big>(Data Carrier Detect) — 
Состояние линии DCD.  Если DCD=1, то на вход DCD СОМ-порта подано 
напряжение +12в(сигнал DCD активен).Если DCD=0, то вход СОМ-порта подано
 напряжение -12В(сигнал DCD пассивен).
									В режиме диагностики этот бит эквивалентен биту OUT2 регистра 
MCR.<br><br>			
				
		</p>



		<p style="font-size : 18pt ; font-style : italic; color : indigo">SCR-регистр временного хранения (чтение/запись)<br>
		(Scratch Pad Register)
		</p>
		Рис.25 Регистр SCR  (Адрес=07h, RD/WR)<br>
			<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_17.gif" align="bottom" alt="SCR UART">
		<p>&nbsp; &nbsp; &nbsp; &nbsp; Регистр временного хранения, на работу 
UART не влияет, предназначен для временного хранения данных (в UART 
i8250 отсутствует).

		</p><br><br>

<a name="M23"></a>
		<h3>1.13 Диагностический режим работы  UART.</h3>
		<p>Режим диагностики UART позволяет проверить работоспособность СОМ-портов без подключения к ним периферийных устройств.
			Режим диагностики включается битом LOOP=1 регистра MCR.<br>
			При этом внутри UART организуется аппаратная "заглушка":
				</p><ul>
					<li>выход передатчика переводится в состояние логической единицы;
					</li><li>вход приемника отключается;
					</li><li>выход сдвигающего регистра передатчика  соединяется со входом приемника;
					</li><li>входы DSR, CTS, RI, DCD отключаются от входных линий 
COM-порта и данные в них поступают из регистра MCR (биты RTS, DTR, OUT1,
 OUT2);
					</li><li>выходы управления модемом переводятся в пассивное состояние (логический ноль).
				</li></ul>
			Аппаратная "заглушка" позволяет передавать и сразу принимать данные 
СОМ-порта, без каких либо подключений к нему. В результате этого 
возможно проверить работу сдвигающего регистра, отработку системы 
прерываний и т.д.
		<p></p>


		&nbsp; &nbsp; &nbsp; &nbsp;
<a name="M24"></a>		
		<h2>§2 Программирование COM-порта.</h2>
<a name="M25"></a>		
		<h3>2.1. Программирование в MS-DOS.</h3>
		<p>&nbsp; &nbsp; В MS-DOS программировать СОМ порты можно всем 
спектром программных средств: прямым кодом микропроцессора(assembler), 
функциями BIOS, средствами операционной системы, языками 
программирования высокого уровня.
		</p>
<a name="M26"></a>
		<h4>2.1.1. Программирование СОМ-порта прямым кодом микропроцессора.</h4>
		<p>&nbsp; &nbsp; Под программированием прямым кодом микропроцессора 
понимается программирование микросхемы UART через порты ввода-вывода с 
помощью команд микропроцессора.
			В системе команд микропроцессора есть команды OUT и IN, которые 
позволяют читать/записать байт по указанному адресу порта ввода/вывода.
			В п.1.12 описаны 12 регистров микросхемы UART, которые полностью 
определяют работу указанной микросхемы.
			Необходимо просто записать нужные данные в эти регистры, чтобы 
заставить СОМ порт выполнить нужные действия.
			При программировании регистров UART нужно учитывать, что в памяти 
BIOS находятся адреса портов ввода/вывода для СОМ1...СОМ4.
		По умолчанию они равны COM1=3F8h, COM2=2F8h, COM3=3E8h, COM4=2E8h , но
 бывают "чудики" которые могут их поменять в настройках BIOS.
		Поэтому перед началом программирования портов в MS-DOS желательно 
проверить адреса СОМ портов.
		В BIOS адрес СОМ порта занимает 2 байта,  и находятся в ячейках памяти
 по адресам  СОМ1: 40...41h, СОМ2: 42...43h, СОМ3: 44...45h, СОМ4: 
46...47h.<br>
			</p><ul>Команды ввода/вывода микропроцессора:
				<li><strong>IN AL,port8</strong>- ввод байта в регистр AL из указанного порта;
				</li><li><strong>IN AL,DX</strong>- ввод байта в регистр AL из порта по адресу указанному в DX;
				</li><li><strong>OUT port8,AL</strong>- вывод байта из регистр AL указанного порта;
				</li><li><strong>OUT DX,AL</strong>- вывод байта из регистр AL порта по адресу указанному в DX;
			</li></ul>
		Пример:
<pre style="font-size : 10pt ; font-style : italic; color : indigo">'записываем  в LCR режим работы сом порта:
'8 бит всимволе,1 стоп бит, проверка паритета на четность,выдавать 0 в случае обрыва, DLAB=1 
	mov al,DBh 'записываем в AL значения для регистра LCR=DBh
	out 3fBh,al'записываем данные в регистр UART LCR
'задаем скорость обмена  115 000 бит/сек  DIM=00h, DLL=01h
	mov al,01h
	out 3f8h,al 'запись регистра DLL=01h
	mov al,00h
	out 03f9h,al 'запись регистра DIM=00h
'снимаем бит DLAB=1
	mov al,5Bh 'DLAB=0
	out 3fBh,al
'послать байт 03h в линию связи
	mov al,03h
	out 3f8h,al 'посылает байт 03h на скорости 115 000 бит/сек
</pre>
		<p>	&nbsp; &nbsp; Перед записью байта данных в регистр передатчика 
необходимо убедиться в том, что регистр хранения передатчика свободен, 
то есть убедиться в том, что передача предыдущего символа завершена. 
			Признаком того, что регистр передатчика свободен, является 
установленный бит 5(THRE=1) регистра состояния линии LSR. <br>
			&nbsp; &nbsp; Аналогично тому как это делается при передаче данных, 
перед вводом символа из порта приемника  необходимо убедиться в том, что
 бит 0 регистра LSR установлен (т.е. DR=1). 
			Это означает, что символ принят из линии и находится в буферном 
регистре приемника. 
		</p>
		<p></p>
<a name="M27"></a>
		<h4>1.1.2. Программирование СОМ-порта с помощью функций BIOS.</h4>
		<p>&nbsp; &nbsp; В BIOS имеются функции которые могут выполняться по 
команде программного прерывания микропроцессора INT 00h...INT 1Fh.
			Так как код этих функций находится в BIOS, то их выполнение возможно 
даже при отсутствии ОС на ПК.<br>
			Кроме этого, функции BIOS работают по номерам СОМ портов, а не по адресу ввода/вывода, что существенно удобней.
		</p>
			Рассмотрим функции BIOS которые применяются для работы с СОМ портом:<br>
<p style="font-size : 18pt ; font-style : italic; color : indigo">Функции по прерыванию INT 14h<br>	</p>
		&nbsp; &nbsp; Программа обработчик этого прерывания, как мы уже говорили, находится в BIOS по вектору 14h.<br>
		BIOS представляет собой энергонезависимую память ПК, поэтому загружать
 программу обрабатывающую прерывание не надо, она всегда находится в 
памяти.<br>
		Вызов функции осуществляется по номеру функции, который записывается в старший байт аккумулятора (AH).<br>
		Пример:
<pre style="font-size : 10pt ; font-style : italic; color : indigo">	mov ah,00h 'номер функции
	int 14h    'вызов функции
</pre>
		Рассмотрим функции вызываемые INT 14h:<br><br>
		<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 14h  AH=00h</font>-инициализация СОМ порта.<br>
		Под инициализацией порта (также применяют термин "открытие") понимают 
установку всех его параметров: номер порта, длину символа, число 
стоп-бит, установку четности и скорость обмена.<br><br>

		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">входные параметры INT14h AH=00h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center">00h</td><td width="210" align="center">байт параметров связи 
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">(n-1), где n-номер COM порта
		</td></tr></tbody></table><br>
		DX: 0000h-COM1, 0001h-COM2, 0002h-COM3, 0003h-COM4<br><br>

		<table frame="border">
		<tbody><tr><td colspan="10" align="center">байт параметров связи
		</td></tr><tr><td>&nbsp; 7 &nbsp; </td><td>&nbsp; 6 &nbsp; </td><td>&nbsp; 5 &nbsp; </td><td>&nbsp; 4 &nbsp; </td><td>&nbsp; 3 &nbsp; </td><td>&nbsp; 2 &nbsp; </td><td> &nbsp; 1 &nbsp; </td><td>&nbsp; 0 &nbsp; </td><td>описание</td><td>допустимые значения
		</td></tr><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td></td><td></td><td></td><td></td><td></td><td>скорость, бод</td><td>000- 110<br>001- 150<br>010- 300<br>011- 600<br>100- 1200<br>101- 2400<br>110- 4800<br>111- 9600
		</td></tr><tr><td></td><td></td><td></td><td align="center">x</td><td align="center">x</td><td></td><td></td><td></td><td>проверка паритета</td><td>00- нет<br>01- нечетность<br>10- нет<br>11- четность
		</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td align="center">x</td><td></td><td></td><td>длина стопового бита</td><td>0- 1<br>1- 2
		</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td align="center">x</td><td align="center">x</td><td>кол. бит в символе</td><td>10- 7<br>11- 8
		</td></tr></tbody></table><br><br>
		
		Пример вызова функции:
<pre style="font-size : 10pt ; font-style : italic; color : indigo">	mov ah,00h 'номер функции
	mov al,EBh '9600 бод,нечетность,1 стоп, 8 бит
	int 14h    'вызов функции
</pre>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=00h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center">байт состояние линии LSR</td><td width="210" align="center">байт состояние модема MSR			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br>
		
		
		В качестве выходных параметром в регистр аккумулятора копируются 
регистры  UART LSR(см.рис.23) и MSR(см.рис.24).
		Из выше сказанного видно, что работа с СОМ портом через функцию BIOS 
INT14h ограничена по скорости и по количеству бит в символе.<br><br>

<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 14h  AH=01h</font>-запись символа в СОМ порт.<br>
При вызове этой функции происходит передача символа из регистра AL в порт с номером заданным в регистре DX.<br>
			<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">входные параметры INT14h AH=01h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center">01h</td><td width="210">символ
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">(n-1), где n-номер COM порта
		</td></tr></tbody></table><br>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=01h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210">байт состояние линии LSR</td><td width="210">символ
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br><br>


<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 14h  AH=02h</font>-чтение символа из СОМ порта.<br>
При вызове этой функции происходит чтение символа из приемного регистра 
СОМ порта, с номером заданным в регистре DX,  в регистра AL .<br>
			<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">входные параметры INT14h AH=02h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center"> 02h</td><td width="210"> 
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">(n-1), где n-номер COM порта
		</td></tr></tbody></table><br>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=02h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210">байт состояние линии LSR</td><td width="210">символ
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br><br>

<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 14h  AH=03h</font>- запрос состояния СОМ порта.<br>
При вызове этой функции происходит чтение регистров LSR и MSR из заданного UART.<br>
			<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=03h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center">03h</td><td width="210"> 
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">(n-1), где n-номер COM порта
		</td></tr></tbody></table><br>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=03h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210">байт состояние линии LSR</td><td width="210">байт состояние модема MSR
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br><br>
	
<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 14h  AH=04h</font>-расширенная инициализация СОМ порта.<br>
Применяется для моделей PS/2.<br>
			<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">входные параметры INT14h AH=04h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center"> 04h</td><td width="210"> установка прерывания 
			</td></tr><tr><td>BX</td><td>установка паритета</td><td>установка стопового бита
			</td></tr><tr><td>CX</td><td>бит в символе</td><td>скорость, бит/сек
			</td></tr><tr><td>DX</td><td colspan="2" align="center">(n-1), где n-номер COM порта
		</td></tr></tbody></table><br>
			<ul>
				<li>AL:  00h-нет прерывания, 01h-есть прерывание
				</li><li>BH: 00h-нет, 01h-нечетность, 02h-четность, 03h-стековая на нечетность, 04h-стековая на четность
				</li><li>BL: 00h-1 стоп,01h-2 стоп (1.5 для 5 бит на символ)
				</li><li>CH: 00h-5 бит,01h- 6 бит,02h- 7 бит,03h- 8 бит
				</li><li>CL: 00h-110,01h-150,02h-300,03h-600,04h-1200,05h-2400,06h-4800,07h-9600,08h-19200 бод
				</li><li>DX: 00h-COM1,01h-COM2,02h-COM3,03h-COM4
			</li></ul>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=04h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210">байт состояние линии LSR</td><td width="210">байт состояние модема MSR
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br><br>
	
<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 14h  AH=05h</font>- чтение/запись управляющего регистра модема MCR.<br>
Применяется для моделей PS/2.<br>
			<table frame="border">
        		<caption>Чтение регистра MCR</caption>
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=05h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center">05h</td><td width="210" align="center"> 00h
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">(n-1), где n-номер COM порта
		</td></tr></tbody></table><br>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=05h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210"></td><td width="210">
			</td></tr><tr><td>BX</td><td></td><td>регистр MCR
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br><br>
		<table frame="border">
        		<caption>Запись регистра MCR</caption>
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=05h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center">05h</td><td width="210"> 01h
			</td></tr><tr><td>BX</td><td></td><td>регистр MCR
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">(n-1), где n-номер COM порта
		</td></tr></tbody></table><br>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT14h AH=05h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210">байт состояние линии LSR</td><td width="210">байт состояние модема MSR
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br><br><br><br>
<a name="M28"></a>
	<h4>2.1.3. Программирование СОМ-порта с помощью средств MS-DOS.</h4>
	<p>Хотя СОМ порт и является основным коммуникационным средством ПК, в 
MS-DOS практически очень мало программных средств для эффективной работы
 с портом.
		Рассмотрим основные программные средства операционной системы MS-DOS:
	</p>
		<p style="font-size : 18pt ; font-style : italic; color : indigo">Функции по прерыванию INT 21h<br>	</p>
		<p>Существуют четыре функции программного прерывания INT 21h для работы с СОМ портом: 03h,04h,3Fh,40h.<br>
		Перед началом описания работы этих функций ознакомимся с понятием 
"описатель". Описатель- это идентификатор последовательного 
устройства(объекта) или файла в системе MS-DOS.
		С точки зрения программы описатель это целое число, которое указывает 
на определённую программную структуру (объект), которая(который) 
обеспечивает работу этого устройства(объекта) с ОС.
		Кто "дружит" с Windows, знает насколько важную роль имеет 
описатель(дескриптор) в этой системе, но начало этого было в MS-DOS.<br>
		В MS-DOS первые номера описателей отданы стандартным последовательным устройствам:
		<table frame="border">
		<tbody><tr align="center"><td>описатель</td><td>имя</td><td>устройство
		</td></tr><tr align="center"><td>0</td><td>CON</td><td>стандартное устройство ввода (клавиатура)
		</td></tr><tr align="center"><td>1</td><td>CON</td><td>стандартное устройство вывода (дисплей)
		</td></tr><tr align="center"><td>2</td><td>CON</td><td>стандартное устройство вывода ошибок (всегда CON)
		</td></tr><tr align="center"><td>3</td><td>AUX</td><td>вспомогательное устройство (по умолчанию COM1)
		</td></tr><tr align="center"><td>4</td><td>PRN</td><td>стандартный вывод на печать (по умолчанию LPT1)
		</td></tr></tbody></table>
		</p>
		Описатель номер 3 называется AUX и адрес ввода-вывода этого устройства
 находится в ячейках BIOS с адресами 40h,41h.
		Эти же ячейки определяют адрес ввода вывода СОМ1, если в эти ячейки 
записать число 2f8h, то устройством ввода-вывода по описателю 3 будет 
СОМ2.
		Таким образом, на описатель 3 (AUX) может быть назначено любое 
последовательное устройство.<br><br>


		<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 21h  AH=03h</font>-ввод символа из AUX.<br>
			Эта функция ожидает ввода символа со стандартного вспомогательного устройства AUX<br>
			<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">входные параметры INT21h AH=03h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr><td>AX</td><td width="210" align="center">03h</td><td width="210">
			</td></tr><tr><td>BX</td><td></td><td>
			</td></tr><tr><td>CX</td><td></td><td>
			</td></tr><tr><td>DX</td><td colspan="2" align="center">
		</td></tr></tbody></table><br>
		После выполнения функция возвращает выходные параметры :<br><br>
		<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">выходные параметры INT21h AH=03h
			</td></tr><tr><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr align="center"><td>AX</td><td width="210"></td><td width="210">символ
			</td></tr><tr align="center"><td>BX</td><td></td><td>
			</td></tr><tr align="center"><td>CX</td><td></td><td>
			</td></tr><tr align="center"><td>DX</td><td colspan="2">
		</td></tr></tbody></table>
		Ввод символов по этой функции не буферизируется и должен опрашиваться на готовность данных в UART.
		Для чтения очередного символа необходимо убеждаться что 5-й бит регистра LSR равен 1 (DR=1).<br><br> 

		<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 21h  AH=04h</font>-запись символа в AUX.<br>
			Эта функция записывает символ в стандартное вспомогательное устройство AUX<br>
			<table frame="border">
        		
			<tbody><tr><td colspan="3" align="center">входные параметры INT21h AH=04h
			</td></tr><tr align="center"><td>регистр</td><td align="center">старший </td><td align="center">младший
			</td></tr><tr align="center"><td>AX</td><td width="210" align="center">04h</td><td width="210">
			</td></tr><tr align="center"><td>BX</td><td></td><td>
			</td></tr><tr align="center"><td>CX</td><td></td><td>
			</td></tr><tr align="center"><td>DX</td><td></td><td>символ
		</td></tr></tbody></table><br>
		Выходных параметров у этой функции нет.<br><br>
		
		<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 21h  AH=3Fh</font>-чтение данных через описатель.<br>
		&nbsp; &nbsp; При вызове этой функции читается количество символов 
записанных в регистре CX из устройства по описателю номер которого 
записан в регистре BX.
		Считанные данные сохраняются в буфере, первый элемент которого указан в
  DS:DX.
		После выполнения функции в регистре AX отражается количество 
полученных символов.
		Если CX=AX и флаг CF=0, то функция выполнена без ошибок.<br><br>

		<font style="font-size : 14pt ; font-style : italic; color : indigo">INT 21h  AH=40h</font>-запись данных через описатель.<br>
		&nbsp; &nbsp; При вызове этой функции количество символов указанных в 
CX записываются в устройство по номеру описателя указанному в BX.
		Данные содержатся в буфере по адресу указанному в DS:DX.
		После вызова в регистр AX возвращается количество переданных символов.<br><br>

	<p style="font-size : 18pt ; font-style : italic; color : indigo">Использование аппаратных прерываний <br>	</p>
		<p>	&nbsp; &nbsp; Так как процесс последовательной передачи данных 
протекает медленно, можно выполнять его в фоновом режиме, используя 
прерывания по окончанию передачи или приема символа. 
			Напомним, что порту COM1 соответствует аппаратное прерывание IRQ4 с 
вектором INT 0Ch, а COM2 - IRQ3 с вектором INT 0Bh. 
			Для разрешения прерываний необходимо установить биты регистра 
управления прерыванием IER (UART), соответствующие тем прерываниям, 
которые нужно обрабатывать. 
			Когда происходит прерывание, программа-обработчик, расположенная по 
указанному вектору прерывания, должна проанализировать причину 
прерывания, прочитав регистр, идентифицирующий прерывания  IIR. 
			Не забудьте, что в конце обработчика аппаратного прерывания должна 
находится последовательность команд: 
</p><pre style="font-size : 10pt ; font-style : italic; color : indigo">	mov al, 20h
	out 20h, al
	iret
</pre>
	Чтобы была возможность обработки нескольких прерываний. 

		<p></p>

	<p style="font-size : 18pt ; font-style : italic; color : indigo">Использование команд MS-DOS <br>	</p>
	<p>В MS-DOS имеется ряд встроенных команд для работы и настройки СОМ 
порта. Команды можно вставлять в пакетные файлы с расширением .bat для 
исполнения их по заданному сценарию.<br><br>

		<font style="font-size : 14pt ; font-style : italic; color : indigo">Команда MODE</font><br>
		Команда Mode предназначена для изменения режима работы периферийных устройств.
		Формат: 
</p><pre style="font-size : 10pt ; font-style : italic; color : indigo">	Mode COMx,бод,паритет,кадр,стоп,P<br>
	  где: x-номер СОМ порта;
	  бод- скорость: 110,150,300,600,1200,2400,4800,9600,19200 бод;
	  паритет-n-нет, o-четность, e-нечетность;
	  кадр- бит на символ: 7,8;
	  стоп- число стоп битов: 1,2
	  P- задает режим повторения попыток передачи при неудаче.
</pre>
		<ul>Пример использования команд MS-DOS для управления Сом портом:

			<li>Создайте текстовый файл (например программой блокнот) Test.txt
		</li><li>Напишите в нем строчки и сохраните:
<pre style="font-size : 10pt ; font-style : italic; color : indigo">	Mode COM1,9600,n,8,1,P
	type c:\data.txt&gt;com1
</pre>
		
		</li><li>Измените расширения файла с .txt на .bat
		</li><li>Создайте текстовый файл c:\data.txt
		</li><li>Запишите в него строку текста и закончите строку Enter
		</li><li>Запустите файл Test.bat

		</li></ul>			
		
В результате исполнения пакетного файла Test.bat строка записанная в 
файле data.txt будет передаваться в СОМ1 со скоростью 9600 бод, с 
проверкой на четность, 8 битами в символе, с одним стоп битом.<br>
В этом пакетном файле мы использовали три MS-DOS команды:
	<ul>
		<li><strong>Mode</strong>- настройка режима СОМ порта
		</li><li><strong>Type</strong>- вывод данных
		</li><li><strong>&gt;</strong>- перенаправление вывода
	</li></ul>
В Windows также возможно исполнение пакетных файлом, но параметры команд необходимо записывать несколько иначе:
<pre style="font-size : 10pt ; font-style : italic; color : indigo">	mode com1 baud=9600 parity=n data=8 stop=1
	type c:\data.txt&gt;com1
</pre>
Кроме того, в Windows строку заканчивать символом Enter не обязательно.
		
		
	<p></p>





		<br><br><br>
<a name="M29"></a>
	<h3>2.2. Программирование в Windows.</h3>
		<p>&nbsp; &nbsp; Программирование в операционных системах Windows 2000
 и выше отличается от программирования в MS-DOS.
			Во-первых, COM1-COM4 в этих системах не имеет стандартных адресов 
ввода вывода и стандартных номеров прерываний, Windows автоматически 
распределяет ресурсы для COM-портов.
			Поэтому если вы захотите программировать СОМ-порт через порты 
ввода-вывода, вам понадобиться, сначала определить ресурсы которые 
занимает СОМ-порт на данном ПК.
			Во-вторых, Windows не дает прямой возможности работать с портами 
ввода-вывода, это возможно только при программировании  на уровне ядра 
ОС (что тоже не просто).
			В принципе такой вариант программирования возможен, то есть пишите 
драйвер ядра для работы с портами ввода-вывода и программу для работы с 
СОМ-портом работающем через этот драйвер.	
		</p>
		<p>&nbsp; &nbsp; Но, не всё так плохо. Естественно разработчики 
Windows предусмотрели возможность работы с коммуникационными портами 
через пользовательский интерфейс Windows.
			Этот способ, наверное, даже проще чем программирование Сом-порта 
через порты ввода-вывода. 
			В Windows к Сом-порту можно обратиться как к файлу(потоку).
			Достоинство этого способа очевидны: вам не надо думать о типе 
микросхемы UART, о номерах портов ввода-вывода и о номерах прерываний.
			ОС незаметно для программиста работает с аппаратной частью 
коммуникационного порта.
		</p>
<a name="M30"></a>
		<h4>2.2.1. Программирование СОМ-порта с помощью API функций Windows.</h4>
		<p>Попробуйте, создать в проводнике папку или файл с именем "СОМ1", сделать это не получится.
			ОС Windows зарезервировала имена от СОМ1 до СОМ9 для работы с СОМ-портами.
			
		</p>
		<p>Рассмотрим подробнее программирование СОМ-порта с помощью API-функций:
		</p>
		<p>1. Для работы с СОМ-портом первое что надо сделать, это открыть порт.<br>
			Сделать это можно с помощью API функции <strong>CreateFile</strong> из библиотеки "kernel32"  :<br>
			Эта функция создает новый объект и присваивает ему описатель, по которому с этим объектом можно будет работать.
			Пример описания функции CreateFile на языке Си:<br>
</p><pre style="font-size : 10pt ; font-style : italic; color : indigo"> HANDLE CreateFile(
     		LPCTSTR               lpFileName,
     		DWORD                 dwDesiredAccess,
     		DWORD                 dwShareMode,
     		LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    		DWORD                 dwCreationDistribution,
     		DWORD                 dwFlagsAndAttributes,
     		HANDLE                hTemplateFile
  			);</pre>	
		<p></p>
		
		Пример декларирования функции CreateFile на языке VB6:<br>
<p style="font-size : 10pt ; font-style : italic; color : indigo">Declare
 Function CreateFile Lib "kernel32" Alias "CreateFileA" (ByVal 
lpFileName As String, ByVal dwDesiredAccess As Long, ByVal dwShareMode 
As Long, ByVal lpSecurityAttributes As Long, ByVal dwCreationDisposition
 As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As 
Long) As Long</p>

		<p>Чтобы открыть СОМ-порт вы должны выполнить эту функцию в коде своей
 программы, с заданными входными параметрами.
			Результатом работы этой функции будет 32-битное число  
handle(описатель), по которому вы сможете обращаться к созданному 
функцией программному объекту связанному с выбранным СОМ-портом.
			</p><ul>Параметры функции CreateFile:
				<li><strong>lpFileName</strong>- имя СОМ-порта. Может принимать 
значения: 
"СОМ1","СОМ2","СОМ3","СОМ4","СОМ5","СОМ6","СОМ7","СОМ8","СОМ9",если 
более одной цифры, то в формате "\\.\СОМ47"
				</li><li><strong>dwDesiredAccess</strong>- режим доступа к файлу.Это
 четырехбайтовое число, которое задает различные режимы доступа к файлу.
									Нас интересует только режим чтение и запись, этот режим 
задаётся числом: С0000000hex в СИ можно вместо числа записать константу с
 именем "GENERIC_READ|GENERIC_WRITE". 
				</li><li><strong>dwShareMode</strong>- режим совместного доступа. 
СОМ-порты ПК не поддерживают совместный доступ, только одна программа 
может открыть порт. Поэтому этот параметр должен быть равен 0(режим 
запрещен).
				</li><li><strong>lpSecurityAttributes</strong>- атрибуты защиты файла. Для СОМ-портов не используется поэтому всегда равны 0 ("NULL").
				</li><li><strong>dwCreationDistribution</strong>- управление режимом
 автосоздания файла. Это четырехбайтовое число, которое для СОМ портов 
всегда должно быть 00000003hex ("OPEN_EXISTING")
				</li><li><strong>dwFlagsAndAttributes</strong>- задает атрибуты создаваемого файла.Это четырехбайтовое число, которое для СОМ портов всегда должно быть 0 ("NULL")
				</li><li><strong>hTemplateFile</strong>- описатель файла "шаблона" по которому создавался файл.Для СОМ-портов не используется поэтому всегда равен 0 ("NULL").
			</li></ul>
<p></p>
	Пример открытия СОМ1 в VB6:	 
		<p style="font-size : 10pt ; font-style : italic; color : indigo">Com_Handle = CreateFile("COM1:", &amp;HC0000000, 0, 0&amp;, &amp;H3, 0, 0)</p>
		<p></p>
	Пример открытия СОМ1 в Си:
	<p style="font-size : 10pt ; font-style : italic; color : indigo">Com_Handle = CreateFile("COM1", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);</p>
<p>2. После открытия СОМ порта можно передавать и принимать данные через этот СОМ-порт.<br>
	Для передачи данных используется API функция <strong>WriteFile</strong> из библиотеки <strong>kernel32.</strong><br>
	Для приёма   данных используется API функция <strong>ReadFile</strong> из библиотеки <strong>kernel32.</strong><br>

</p>
Пример описания функции ReadFile и WriteFile на языке Си:<br>
<pre style="font-size : 8pt ; font-style : italic; color : indigo">BOOL ReadFile(
  HANDLE       hFile, // описатель сОМ порта
  LPVOID       lpBuffer, // Указатель на буфер, который принимает прочитанные данные из порта
  DWORD        nNumberOfBytesToRead,// Число байтов, которые читаются из порта
  LPDWORD      lpNumberOfBytesRead, // Указатель на переменную, которая получает число прочитанных байтов
  LPOVERLAPPED lpOverlapped    // Указатель на структуру OVERLAPPED.
			);

BOOL WriteFile(
  HANDLE       hFile,// описатель сом порта
  LPCVOID      lpBuffer,// Указатель на буфер, содержащий данные, которые будут записаны в файл. 
  DWORD        nNumberOfBytesToWrite,// Число байтов, которые будут записаны в файл.
  LPDWORD      lpNumberOfBytesWritten,//  Указатель на переменную, которая получает число записанных байтов
  LPOVERLAPPED lpOverlapped // Указатель на структуру OVERLAPPED
	);</pre>

Пример декларирования функции ReadFile и WriteFile на языке VB6:<br>
<p style="font-size : 10pt ; font-style : italic; color : indigo">
Declare Function ReadFile Lib "kernel32" (ByVal hFile As Long, lpBuffer 
As Any, ByVal nNumberOfBytesToRead As Long, lpNumberOfBytesRead As Long,
 lpOverlapped As Long) As Boolean<br><br>

Declare Function WriteFile Lib "kernel32" (ByVal hFile As Long, lpBuffer
 As Any, ByVal nNumberOfBytesToWrite As Long, lpNumberOfBytesWritten As 
Long, lpOverlapped As Long) As Boolean
</p>
С помощью этих функций из программного кода можно читать или записывать данные в указанный буфер.<br>
Пример чтения 255 байт из порта в массив на языке VB6:<br>
<p style="font-size : 10pt ; font-style : italic; color : indigo">Dim File_Buffer(255) As Byte 'приемный буфер<br>
Dim Com_Byte_Read As Long 'количество принятых байт<br>
Dim Retval As Boolean<br>
Retval = ReadFile(Com_Handle, File_Buffer(0), 255, Com_Byte_Read, 0)<br>
</p>
<p>3. После окончания работы с портом его нужно закрыть.<br>
	Закрытие порта осуществляется API функцией <strong>CloseHandle</strong> из библиотеки <strong>kernel32.</strong><br>
</p>
Пример описания функции CloseHandle на языке Си:<br>
<pre style="font-size : 10pt ; font-style : italic; color : indigo">BOOL CloseHandle(
         HANDLE hObject   // описатель порта
          );</pre>
Пример декларирования функции CloseHandleна языке VB6:<br>
<p style="font-size : 10pt ; font-style : italic; color : indigo">
Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Boolean
</p>
Пример закрытия порта на языке VB6:
<p style="font-size : 10pt ; font-style : italic; color : indigo">
Dim Com_Exit as Boolean<br>
Com_Exit = CloseHandle(Com_Handle)
</p><br>
4. Настройка режима работы сом порта осуществляется с помощью структур 
данных, которые представляют из себя набор переменных разного типа.
Структуруы загружаются и читаются с помощью API функций.<br>
Рассмотрим основные структуры для настройки режимов работы сом порта:<br>

<p style="font-size : 18pt ; font-style : italic; color : indigo">DCB структура</p>
Структура DCB определяет основные настройки СОМ порта.<br>
В ней содержиться реальная информация из регистров UART.
<pre style="font-size : 10pt ; font-style : italic; color : indigo">  typedef struct _DCB {
      DWORD DCBlength;            // длина структуры (DCB)
      DWORD BaudRate;             // скорость в бит/сек
      DWORD fBinary:1;            // бинарный режим
      DWORD fParity:1;            // разрешение контроля четности
      DWORD fOutxCtsFlow:1;       // слежение за CTS
      DWORD fOutxDsrFlow:1;       // слежение за DSR
      DWORD fDtrControl:2;        // режим работы сигнала DTR
      DWORD fDsrSensitivity:1;    // чувствительность к DSR
      DWORD fTXContinueOnXoff:1;  // продолжение передачи при XOFF
      DWORD fOutX:1;              // программное управление потоком при передачи (XON/XOFF)
      DWORD fInX:1;               // программное управление потоком при приеме (XON/XOFF)
      DWORD fErrorChar:1;         // замена ошибочных символов
      DWORD fNull:1;              // действия при приёме нулевого символа
      DWORD fRtsControl:2;        // Задает режим управления потоком для сигнала RTS
      DWORD fAbortOnError:1;      // игнорирование запись/чтение при ошибке
      DWORD fDummy2:17;           // зарезервировано
      WORD  wReserved;            // не используется, равно 0
      WORD  XonLim;               // мин. количество символов для посылки XON
      WORD  XoffLim;              // макс. кол-во символов для посылки XOFF
      BYTE  ByteSize;             // количество бит в символе
      BYTE  Parity;               // режим паритета 0-4=no,odd,even,mark,space
      BYTE  StopBits;             // длина стопового бита 0,1,2 = 1, 1.5, 2
      char  XonChar;              // символ для XON
      char  XoffChar;             // символ для XOFF
      char  ErrorChar;            // символ для замены ошибок
      char  EofChar;              // символ конца данных
      char  EvtChar;              // символ события
      WORD  wReserved1;           // резервный
  } DCB;
</pre>

Для работы с DCB структурой используют API функции из библиотеки <strong>kernel32.</strong>:<br><br>
<strong>BuildCommDCB</strong>- заполняет указанную структуру DCB 
значениями, заданными в строке управления устройством. Строка управления
 устройством использует синтаксис команды mode MS-DOS.<br>
<strong>SetCommState</strong>- конфигурирует коммуникационное устройство
 согласно данным указанным в структуре DCB. Функция повторно 
инициализирует все аппаратные и управляющие настройки, но не опорожняет 
очереди вывода или ввода данных.<br>
<strong>GetCommState</strong>- читает DCB структуру.<br><br>


<p style="font-size : 18pt ; font-style : italic; color : indigo">COMMTIMEOUTS структура</p>
Данная структура задает временные параметры(задержки и таймауты) работы 
СОМ порта и определяет поведение функций ReadFile и WriteFile.
<pre style="font-size : 10pt ; font-style : italic; color : indigo">typedef struct _COMMTIMEOUTS {
  DWORD ReadIntervalTimeout; //интервал между символами
  DWORD ReadTotalTimeoutMultiplier; //множитель для периода простоя чтения
  DWORD ReadTotalTimeoutConstant; //постоянная для периода простоя чтения
  DWORD WriteTotalTimeoutMultiplier; //множитель для периода простоя записи
  DWORD WriteTotalTimeoutConstant; //постоянная для периода простоя записи
} COMMTIMEOUTS, 
*LPCOMMTIMEOUTS;
</pre>
Для работы с COMMTIMEOUTS структурой используют API функции из библиотеки <strong>kernel32.</strong>:<br><br>

<strong>SetCommTimeouts</strong>- устанавливает параметры простоя для всех операций чтения и записи для заданного коммуникационного устройства.<br>
<strong>GetCommTimeouts</strong>- извлекает данные о параметрах простоя для всех  операций чтения и записи на заданном коммуникационном устройстве.<br><br>


<p style="font-size : 18pt ; font-style : italic; color : indigo">COMMSTAT структура</p>
Структура которая сообщает статус СОМ порта после обнаружения ошибки связи.
<pre style="font-size : 10pt ; font-style : italic; color : indigo">  typedef struct _COMSTAT {
  DWORD fCtsHold    :1;//ожидание символа CTS(готовности к приёму)
  DWORD fDsrHold    :1;//ожидание сигнала DSR(готовности модема)
  DWORD fRlsdHold   :1;//ожидание RSLD(детектор сигнала с линии)
  DWORD fXoffHold   :1;//ожидание передачи (был принят XOFF)
  DWORD fXoffSent   :1;//передача символа XOFF
  DWORD fEof        :1;//принят символ конец данных EOF
  DWORD fTxim       :1;//имеется очередь символов для передачи
  DWORD fReserved   :25;//резерв
  DWORD cbInQue;//число байтов полученых от ReadFile
  DWORD cbOutQue;//число байтов для WriteFile
} COMSTAT, 
*LPCOMSTAT;

</pre>
Для работы с COMMSTAT структурой используют API функции из библиотеки <strong>kernel32.</strong>:<br><br>

<strong>ClearCommError</strong>- Функция ClearCommError извлекает 
информацию об коммуникационной ошибке и сообщает о текущем состоянии 
коммуникационного устройства. 
				Функция вызывается тогда, когда происходит ошибка обмена информацией
 и сбрасывает флажок ошибки устройства, чтобы включить в работу 
дополнительные операции ввода и вывода данных (I/O).<br><br>


<p style="font-size : 18pt ; font-style : italic; color : indigo">COMMPROP структура</p>
Структура которая сообщает информацию о свойствах коммуникационного устройства.
<pre style="font-size : 10pt ; font-style : italic; color : indigo">  typedef struct _COMMPROP {
  WORD wPacketLength;//размер пакета данных
  WORD wPacketVersion;//версия структуры
  DWORD dwServiceMask;//битовая маска услуг поставщика
  DWORD dwReserved1;//резерв
  DWORD dwMaxTxQueue;//макс. размер передающего буфера
  DWORD dwMaxRxQueue;//макс. размер приёмного буфера
  DWORD dwMaxBaud;//макс. скорость в бит/сек
  DWORD dwProvSubType;//тип коммуникационного устройства
  DWORD dwProvCapabilities;//возможности предлагаемые поставщиком
  DWORD dwSettableParams;//параметр который может изменяться
  DWORD dwSettableBaud;//скорость разрешенная к использованию
  WORD wSettableData;//число битов в символе которые разрешено задавать
  WORD wSettableStopParity;//стоповые биты и паритет которые могут быть выбраны
  DWORD dwCurrentTxQueue;//текущий размер передающего буфера
  DWORD dwCurrentRxQueue;//текущий размер приёмного буфера
  DWORD dwProvSpec1;//данные определяемые поставщиком
  DWORD dwProvSpec2;//данные определяемые поставщиком
  WCHAR wcProvChar;//знаки определяемые поставщиком
} COMMPROP;


</pre>
Для работы с COMMPROP структурой используют API функции из библиотеки <strong>kernel32</strong>:<br><br>

<strong>GetCommProperties </strong>- Функция GetCommProperties извлекает информацию о коммуникационных характеристиках указанного коммуникационного устройства.

<br><br>
<a name="M31"></a>
<h4>2.2.2. Программирование СОМ-порта с помощью внешних компонент ActiveX.</h4>
	<p>&nbsp; &nbsp; Программирование работы СОМ порта с помощью внешних 
компонент один из наиболее распространённых и простых способов работы с 
СОМ портом.
		Внешний компонент это программный модуль, который выполняет заданные 
функций и обладает всеми параметрами программного объекта.
		Внешний компонент разрабатывается по технологии ActiveX, что позволяет
 ему встраиваться в любые проекты программ, написанных на языках 
программирования поддерживающих эту технологию.
		Практически все современные средства разработки программ поддерживают 
технологию ActiveX.
		Вы можете создавать проект своего приложения на C++, Delphi, VB, 
1C,MS-Office  и для работы с СОМ портом подключить готовую внешнюю 
компоненту.
		При этом вам не нужно разбираться, как работает СОМ порт, это делает 
программный объект внешней компоненты, разработчик только использует 
свойства, методы и события этого объекта.
		Технология ActiveX является логическим продолжением  dll, DDE, OLE, 
COM технологий. 
	</p>
	<p>&nbsp; &nbsp; Внешняя компонента(элемент ActiveX) является 
законченным программным продуктом и обладает всеми авторскими правами.
		Поэтому разработчику необходимо помнить, что подключая элемент 
ActiveX, вы подключаете код чужой программы к своему проекту, и 
соответственно часть вашей программы будет написана разработчиком 
компоненты, что требует оплаты.
		Внешних компонент для работы с СОМ портами написано большое 
количество.
		Необходимо определиться какую компоненту, и на каких условиях вы 
будете применять в своём проекте.
		
	</p>
	<p>Внешние компоненты оформлены в виде файлов и имеют расширение .ocx 
либо более раннее .dll.
		Для того чтобы внешнюю компоненту можно было использовать в проекте, 
она должна быть зарегистрирована в ОС.
		Регистрация компоненты осуществляется записью ключей в реестр ОС, с 
помощью специальной программы или команды "Зарегистрировать" из 
контекстного меню файла.
	</p>
	<p>Для рассмотрения возьмём известную компоненту MSCOMM32.ocx 
написанную Microsoft и включенную в пакет разработчика Visual Studio 
Enterprise.<br>
		Подключите MSCOMM32.ocx  к вашему проекту.
		После подключения компоненты к проекту вы сможете работать с объектом MSComm1.
		</p><ul> Основные своиства объекта<strong>MSCOMM1</strong>:
			<li> <strong>MSComm1.CommPort</strong>- задает номер Сом порта
			</li><li><strong>MSComm1.Settings</strong>- задает основные параметры порта
			</li><li><strong>MSComm1.PortOpen</strong>- открывает и закрывает порт
			</li><li><strong>MSComm1.Output</strong> -передает данные в порт
			</li><li><strong>MSComm1.Input</strong>- читает данные из порта
			</li><li><strong>MSComm1.RTSEnable</strong>- управление сигналом RTS
 			</li><li><strong>MSComm1.DTREnable</strong>- управление сигналом DTR
			</li><li><strong>MSComm1.CTSHolding</strong>- состояние сигнала CTS
			</li><li><strong>MSComm1.DSRHolding</strong>- состояние сигнала DSR
			</li><li><strong>MSComm1.DCDHolding</strong>- состояние сигнала DCD
		</li></ul>
		Пример работы с СОМ портом на VB:<br>
	<pre style="font-size : 10pt ; font-style : italic; color : indigo">Private Sub Command1_Click()
    Dim Data_S As String

    MSComm1.CommPort = 1 'номер сом порта
    MSComm1.PortOpen = True 'открыть порт
    MSComm1.Settings = "9600,n,8,1" 'скорость 9600 бит/сек, без паритета, 8 бит в симв/, 1 стоп.
    Data_S = MSComm1.Input 'принять данные из порта
    MSComm1.Output = "Hello" ' передать данные в порт
    MSComm1.DTREnable = True ' включить сигнал DTR
    MSComm1.PortOpen = False 'закрыть порт
End Sub
	</pre>
В данной программе при нажатии кнопки 1 открывается порт СОМ1 на 
скорости 9600 бит/сек, без проверки паритета, 8 бит в символе, с одним 
стоповым битом.
В переменную DATA_S считывается строка символов из приёмного буфера СОМ1
 и в передающий буфер СОМ1 выводится слово "Hello".
После этого включается сигнал DTR и порт закрывается.
<p></p>
<p>Как видно из приведенного примера работа с Сом портом, при использовании элемента ActiveX, достаточно проста.<br>
	Кроме указанных свойств компонент MSCOMM32.ocx имеет большое количество
 других свойств, событий и методов, которые полнофункционально реализуют
 работу СОМ порта в ОС Windows.
</p>

<a name="M34"></a>
		<br><br><br>
		<h2>Приложение 1</h2>
		<h4>Примеры программирования COM-порта в Win32 с помощью API функций.</h4>			
		<p>Реализация простых функций com-порта:<br>
			&nbsp; &nbsp;-открытие порта<br>
			&nbsp; &nbsp;-настройка порта<br>
			&nbsp; &nbsp;-запись текста в порт<br>
			&nbsp; &nbsp;-чтение текста из порта<br>
			&nbsp; &nbsp;-закрытие порта<br>
		</p>
		<p>Напишем программу реализующие эти функции на различных языках программирования:
			VB6, MASM32, C
		</p>
		Исходник на VB6  COMAPIvb v.1.00 &nbsp;  <a href="http://www.softelectro.ru/comapivb.rar"> Скачать </a>&nbsp;&nbsp; <font color="maroon"></font><br>
		Исходник на MASM32  COMAPIas v.1.00 &nbsp;  <a href="http://www.softelectro.ru/comapias.rar"> Скачать </a>&nbsp;&nbsp; <font color="maroon"></font><br>
		Исходник на C,  скомпилирован на MS VC6++ COMAPIc v.1.00 &nbsp;  <a href="http://www.softelectro.ru/comapic.rar"> Скачать </a>&nbsp;&nbsp; <font color="maroon"></font><br>		
			<p>Рис.28  Окно проекта COMAPI</p>
		<img src="%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20COM%20%D0%BF%D0%BE%D1%80%D1%82%D0%B0%20%D0%9F%D0%9A_files/rs232_27.gif" alt="Practical representation of the inferface RS-232"><br>
			
		<p align="left">Программа работает следующим образом:<br>
			&nbsp; &nbsp; -при нажатии кнопки Open port окрывается сом-порт СОМ1<br>
			&nbsp; &nbsp; -настройка СОМ1: 1200 бод, 8 бит на символ, с 1 стоповым битом, без проверки паритета<br>
			&nbsp; &nbsp; -при нажатии кнопки Write port , стока записанная в Text2(Hello World!) посылается в СОМ1 <br>
			&nbsp; &nbsp; -при нажатии кнопки Read port, в Text1 помещается строка из приемного буфера СОМ1<br>
			&nbsp; &nbsp; -при нажатии кнопки Close port, порт СОМ1 закрывается<br>
		</p>		
		
		<h4>Пример 1 Программа COMAPI  на VB6 из пакета Visual Studio Enterprise с SP6  в ОС XP SP3</h4>
	<ul>
		<li>создаем проект Standart.exe
		</li><li>именуем проект COMAPIvb v.1.00
		</li><li>добавляем к проекту модуль (ADD Module)
		</li><li>размещаем на форме 4 кнопки
		</li><li>размещаем на форме 2 текстовых окна
		</li><li>вводим титул кнопок:Open port, Close Port, Read Port, Write port
		</li><li>в окно Text1 будет выводится строка полученная из сом порта
		</li><li>в окне Text2 будет находится строка которую будем посылать через порт 
	</li></ul>
	



		<p>Вводим код модуля:
		</p>
<pre><font style="font-style : italic; font-size : 8pt; color :  blue ">
'COMAPIvb v.1.01
'Yahkardin Vladimir
'www.softelectro.ru
'Russia, Peterburg
'06.04.2012

Option Explicit

'The declaration of used functions API
Declare Function CreateFile Lib "kernel32" Alias "CreateFileA" (ByVal lpFileName As String, ByVal dwDesiredAccess As Long, ByVal dwShareMode As Long, ByVal lpSecurityAttributes As Long, ByVal dwCreationDisposition As Long, ByVal dwFlagsAndAttributes As Long, ByVal hTemplateFile As Long) As Long
Declare Function ReadFile Lib "kernel32" (ByVal hFile As Long, lpBuffer As Any, ByVal nNumberOfBytesToRead As Long, lpNumberOfBytesRead As Long, lpOverlapped As Long) As Boolean
Declare Function WriteFile Lib "kernel32" (ByVal hFile As Long, lpBuffer As Any, ByVal nNumberOfBytesToWrite As Long, lpNumberOfBytesWritten As Long, ByVal lpOverlapped As Long) As Boolean
Declare Function CloseHandle Lib "kernel32" (ByVal hObject As Long) As Long
Declare Function SetCommState Lib "kernel32" (ByVal hFile As Long, lpDCB As DCB) As Boolean
Declare Function SetCommTimeouts Lib "kernel32" (ByVal hFile As Long, lpCommTimeouts As COMMTIMEOUTS) As Boolean
Declare Function GetLastError Lib "kernel32" () As Long


Public Com_Handle As Long 'Descriptor of port
Public Buf(255) As Byte 'The buffer of port
Public Com_Byte_Read As Long 'количество принятых байт
'Structure for parameter setup of port
Type DCB
    DCBlength As Long       'Length of structure in byte.
    BaudRate As Long        'Speed of data exchangeб, bps
    fBitFields As Long      'Bit field for setting of port
    wReserved As Integer    'Reserved
    XonLim As Integer       'minimum number of bytes in the buffer to send Xon
    XoffLim As Integer      'maximum number of bytes in the buffer for sending Xof
    ByteSize As Byte        'the number of bits in a symbol
    Parity As Byte          'parity check mode
    StopBits As Byte        'Stop bit length
    XonChar As Byte         'character code Xon
    XoffChar As Byte        'character code Xof
    ErrorChar As Byte       'code symbol error
    EofChar As Byte         'character code data end
    EvtChar As Byte         'character code Events
    wReserved1 As Integer   'Reserved
End Type
Public DCB1 As DCB
'Structure for parameter setup of port
Type COMMTIMEOUTS
    ReadIntervalTimeout As Long       'интервал между символами
    ReadTotalTimeoutMultiplier As Long        'множитель для периода простоя чтения
    ReadTotalTimeoutConstant As Long      'постоянная для периода простоя чтения
    WriteTotalTimeoutMultiplier As Long    'множитель для периода простоя записи
    WriteTotalTimeoutConstant As Long       'постоянная для периода простоя записи
End Type
Public COMMTIMEOUTS1 As COMMTIMEOUTS


'Function of opening of port
Function Com_Open()
    Dim Retval As Long
    Dim Retval_B As Boolean
    Dim Retval_S As Boolean
    
    Retval = CreateFile("COM1:", &amp;HC0000000, 0, 0, 3, 0, 0)
    If Retval = -1 Then
        MsgBox ("The open error of port:" &amp; GetLastError)
    Else
        Com_Handle = Retval
        'set dcb
        DCB1.BaudRate = 1200
        DCB1.ByteSize = 8
        DCB1.DCBlength = 28
        DCB1.EofChar = 0
        DCB1.ErrorChar = 0
        DCB1.EvtChar = 0
        DCB1.fBitFields = 1
        DCB1.Parity = 0
        DCB1.StopBits = 0
        DCB1.wReserved = 0
        DCB1.wReserved1 = 0
        DCB1.XoffChar = 0
        DCB1.XoffLim = 0
        DCB1.XonChar = 0
        DCB1.XonLim = 0
        Retval_S = SetCommState(Com_Handle, DCB1)
        'set timeout
        COMMTIMEOUTS1.ReadIntervalTimeout = -1
        COMMTIMEOUTS1.ReadTotalTimeoutConstant = 0
        COMMTIMEOUTS1.ReadTotalTimeoutMultiplier = 0
        COMMTIMEOUTS1.WriteTotalTimeoutConstant = 5000
        COMMTIMEOUTS1.WriteTotalTimeoutMultiplier = 0
        Retval_B = SetCommTimeouts(Com_Handle, COMMTIMEOUTS1)
        
        If Retval_B = False Or Retval_S = False Then
            MsgBox ("Error DCB&amp;Timout:" &amp; GetLastError)
        End If
        MsgBox ("Open port HANDLE:" &amp; Com_Handle)
       
    End If
    
End Function
'Function of closing the port
Function Com_Close()
    Dim Retval As Long
    
    Retval = CloseHandle(Com_Handle)
    If Retval = 0 Then
        MsgBox ("Close port ERROR:" &amp; GetLastError)
    Else
        MsgBox ("Close port")
    End If
End Function

'Recording function to the port
Function Com_Write()
    Dim Len_Buf As Long
    Dim Retval As Boolean
    PurgeBuf
    Retval = WriteFile(Com_Handle, Buf(0), 255, Len_Buf, 0)
    If Retval = False Then
        MsgBox ("Write port ERROR:" &amp; GetLastError)
    Else
        MsgBox ("Data write: Ok")
    End If
   
End Function

'function of reading from the port
Function Com_Read()
    Dim Retval As Boolean
    PurgeBuf
    Retval = ReadFile(Com_Handle, Buf(0), 255, Com_Byte_Read, 0)
    If Retval = False Then
        MsgBox ("Read port ERROR:" &amp; GetLastError &amp; Err.Description)
    Else
        MsgBox ("Data read: Ok")
    End If
  
End Function
'clear buffer
Sub PurgeBuf()
    Dim a As Integer
    
    For a = 0 To 255
        Buf(a) = &amp;H20
    Next a
End Sub

</font>
</pre>
Вводим код формы:
<pre><font style="font-style : italic; font-size : 8pt; color :  blue ">
'COMAPIvb v.1.01
'Yahkardin Vladimir
'www.softelectro.ru
'Russia, Peterburg
'06.04.2012
Option Explicit

'Open port
Private Sub Command1_Click()
    Dim Retval As Boolean
    Retval = Com_Open
End Sub
'Close port
Private Sub Command2_Click()
    Dim Retval As Boolean
    Retval = Com_Close
End Sub
'Read port
Private Sub Command3_Click()
    Dim s As String
    Dim a As Long
    Com_Read
    For a = 1 To Com_Byte_Read
            s = s &amp; Chr(Buf(a - 1))
    Next a
    Text1.Text = s
End Sub
'Write port
Sub Command4_Click()
    Dim s As String
    Dim n As Long
    Dim a As Integer
    Dim Retval As Long
    s = Text2.Text
    s = Mid(s, 1, 255)
    n = Len(s)
    For a = 1 To n
        Buf(a - 1) = Asc(Mid(s, a, 1))
    Next a
    Com_Write
End Sub
'Exit programm
Private Sub Form_Unload(Cancel As Integer)
    Dim Retval As Long
    Retval = CloseHandle(Com_Handle)
End Sub

</font>
</pre>
<h4>Пример 2 Программа COMAPIas  на MASM32 v.10  в ОС XP SP3</h4>
	<ul>
		<li>создаем файл comapias.asm
		</li><li>указываем прототипы и подключаем библиотеки
		</li><li>декларируем данные
		</li><li>получаем дескриптор приложения
		</li><li>создаем функцию WinMain
		</li><li>создаем главное окно
		</li><li>создаем процедуру обработки сообщения окна
		</li><li>создаем 4 кнопки
		</li><li>создаем 2 окна редактирования
		</li><li>пишем коды обработки событий кнопок
		
	</li></ul>
<pre><font style="font-style : italic; font-size : 8pt; color :  blue ">	

;COMAPIas v.1.00
;htpp:\\www.softelectro.ru
;Electron18  
.386
.model flat,stdcall
option casemap:none

STYLBTN equ WS_CHILD + BS_DEFPUSHBUTTON + WS_VISIBLE
STYLEDT equ WS_CHILD+WS_VISIBLE+WS_BORDER+WS_TABSTOP 

WinMain PROTO :DWORD,:DWORD,:DWORD,:DWORD
PurgeBuf PROTO 

include \masm32\include\windows.inc
include \masm32\include\user32.inc
include \masm32\include\kernel32.inc
includelib \masm32\lib\user32.lib
includelib \masm32\lib\kernel32.lib

.DATA
    ClassName db "SimpleWinClass",0
    AppName  db "COMAPIas v.1.00",0
        ;data button
   
    CLSBUTN         DB 'BUTTON',0
    CPBUT1          DB 'Open port',0
    HWNDBTN1        DD 0
    CPBUT2          DB 'Close port',0
    HWNDBTN2        DD 0
    CPBUT3          DB 'Read port',0
    HWNDBTN3        DD 0
    CPBUT4          DB 'Write port',0
    HWNDBTN4        DD 0
        ;data edit
    CLSEDIT         DB 'EDIT',0
    CPEDT1          DB ' ',0
    HWNDEDT1        DD 0
    CPEDT2          DB 'Hello World!',0
    HWNDEDT2        DD 0
    TEXT            DB 'Строка редактирования',0

        ;Message App
        ;App message
    uType           EQU 0
    lpCapApp        DB "App message",0
    lpApp1          DB "Open port HANDLE:", 6 dup(" "),0
    lpApp2          DB "Close port",0
    lpApp3          DB "Data read: Ok",0
    lpApp4          DB "Data write: Ok",0
    
        ;error message
    lpCapERR        DB "Error Message",0       
    lpERR1          DB "Open port Error:",10 dup(" "),0
    lpERR2          DB "DCB Structure ERROR:",10 dup(" "),0
    lpERR3          DB "SetComm Function ERROR:",10 dup(" "),0
    lpERR4          DB "Read port ERROR:",10 dup(" "),0
    lpERR5          DB "Write port ERROR:",10 dup(" "),0
    lpERR6          DB "Close port ERROR:",10 dup(" "),0
   
        ;data com port
    Mem1            DD 0
    Par1            DB "%lu",0
    Buf             DB 255 dup(" "),0
    HWNDCOM         DD 0
    LenBuf          DD 0
    NumCOM          DB "COM1:",0
    COMSETTING      DB "Com1: baud=1200 parity=N data=8 stop=1",0
    DCB1            DCB &lt;&gt;  

.DATA?
    hInstance       HINSTANCE ?
    CommandLine     LPSTR ?
   

.CODE
START:
	INVOKE GetModuleHandle, NULL
	   mov    hInstance,eax                                                ;handle app
	INVOKE GetCommandLine                                                  ;handle command line
	INVOKE WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT             ;input to app
	INVOKE ExitProcess,eax                                                 ;exit app
                                                                             ;main window
WinMain PROC hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD
	LOCAL wc:WNDCLASSEX
	LOCAL msg:MSG
	LOCAL hwnd:HWND
	   mov   wc.cbSize,SIZEOF WNDCLASSEX
	   mov   wc.style, CS_HREDRAW or CS_VREDRAW
	   mov   wc.lpfnWndProc, OFFSET WndProc
	   mov   wc.cbClsExtra,NULL
	   mov   wc.cbWndExtra,NULL
	   push  hInst
	   pop   wc.hInstance
	   mov   wc.hbrBackground,4;COLOR_MENU;COLOR_WINDOW
	   mov   wc.lpszMenuName,NULL
	   mov   wc.lpszClassName,OFFSET ClassName
	INVOKE LoadIcon,NULL,IDI_APPLICATION 
	   mov   wc.hIcon,eax                                                  ;handle icon
	   mov   wc.hIconSm,0
	INVOKE LoadCursor,NULL,IDC_ARROW
	   mov   wc.hCursor,eax                                                ;handle cursor
	INVOKE RegisterClassEx, addr wc                                        ;register class window
                                                                             ;create main window
	INVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,WS_OVERLAPPEDWINDOW,20,20,800,200,NULL,NULL,hInst,NULL
	   mov   hwnd,eax                                     
	INVOKE ShowWindow, hwnd,SW_SHOWNORMAL                                  ;show window
	INVOKE UpdateWindow, hwnd                                              ;update window

                                                                             ;loop message
	.WHILE TRUE
                INVOKE GetMessage, ADDR msg,NULL,0,0                         ;get message
                .BREAK .IF (!eax)                           
                INVOKE TranslateMessage, ADDR msg                            ;get key char
                INVOKE DispatchMessage, ADDR msg                             ;call Win Proc
                
	.ENDW
	           mov     eax,msg.wParam                                     
	           ret
WinMain endp


                                                                             ;procedure window
WndProc PROC hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM

      .IF uMsg==WM_DESTROY
	INVOKE PostQuitMessage,NULL  
      .ELSEIF uMsg==WM_COMMAND
                mov EAX, HWNDBTN1 
                cmp lParam, EAX
                je  BUTTON1_CLICK

                mov EAX, HWNDBTN2 
                cmp lParam, EAX
                je  BUTTON2_CLICK

                mov EAX, HWNDBTN3 
                cmp lParam, EAX
                je  BUTTON3_CLICK

                mov EAX, HWNDBTN4 
                cmp lParam, EAX
                je  BUTTON4_CLICK     

      .ELSEIF uMsg==WM_CREATE    
                                                                                ;create button1..4
            INVOKE CreateWindowEx, 0,OFFSET CLSBUTN,OFFSET CPBUT1,STYLBTN,10,10,100,20,hWnd,0,hInstance,0
                mov HWNDBTN1, EAX                                               ; handle button1
            INVOKE CreateWindowEx, 0,OFFSET CLSBUTN,OFFSET CPBUT2,STYLBTN,10,40,100,20,hWnd,0,hInstance,0
                mov HWNDBTN2, EAX                                               ; handle button2
            INVOKE CreateWindowEx, 0,OFFSET CLSBUTN,OFFSET CPBUT3,STYLBTN,10,70,100,20,hWnd,0,hInstance,0
                mov HWNDBTN3, EAX                                               ; handle button3
            INVOKE CreateWindowEx, 0,OFFSET CLSBUTN,OFFSET CPBUT4,STYLBTN,10,100,100,20,hWnd,0,hInstance,0
                mov HWNDBTN4, EAX                                               ; handle button4
                                                                                ;create edit1 and edit2
            INVOKE CreateWindowEx, 0,OFFSET CLSEDIT,OFFSET CPEDT1,STYLEDT,120,70,600,20,hWnd,0,hInstance,0
                mov HWNDEDT1, EAX                                               ; handle edit1
            INVOKE CreateWindowEx, 0,OFFSET CLSEDIT,OFFSET CPEDT2,STYLEDT,120,100,600,20,hWnd,0,hInstance,0
                mov HWNDEDT2, EAX                                               ; handle edit2
      
	.ELSE
		INVOKE DefWindowProc,hWnd,uMsg,wParam,lParam                        ;default message
		    ret
	.ENDIF
      jmp ENDMESS
      
BUTTON1_CLICK:                                                                  ;open port
            INVOKE CreateFile,OFFSET NumCOM, GENERIC_READ or GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL,NULL
                mov HWNDCOM, eax
                .IF EAX==-1
                    INVOKE GetLastError
                        mov Mem1,eax
                    INVOKE wsprintf,OFFSET lpERR1(17),OFFSET Par1,Mem1;
                    INVOKE MessageBoxA,NULL,OFFSET lpERR1,OFFSET lpCapERR,uType
                .ELSE
                    INVOKE wsprintf,OFFSET lpApp1(18),OFFSET Par1,HWNDCOM
                    INVOKE MessageBoxA,NULL,OFFSET lpApp1,OFFSET lpCapApp,uType
                    INVOKE BuildCommDCB,OFFSET COMSETTING, OFFSET DCB1
                    .IF EAX==0
                        INVOKE GetLastError
                            mov Mem1,eax
                        INVOKE wsprintf,OFFSET lpERR2(21),OFFSET Par1,Mem1;
                        INVOKE MessageBoxA,NULL,OFFSET lpERR2,OFFSET lpCapERR,uType
                    .ENDIF
                    INVOKE SetCommState,HWNDCOM,OFFSET DCB1
                    .IF EAX==0
                        INVOKE GetLastError
                            mov Mem1,eax
                        INVOKE wsprintf,OFFSET lpERR3(24),OFFSET Par1,Mem1;
                        INVOKE MessageBoxA,NULL,OFFSET lpERR3,OFFSET lpCapERR,uType
                    .ENDIF
                .ENDIF
            jmp ENDMESS
            
BUTTON2_CLICK:                                                                  ;close port
            INVOKE CloseHandle,HWNDCOM
             .IF EAX==0
                INVOKE GetLastError
                    mov Mem1,eax
                INVOKE wsprintf,OFFSET lpERR6(18),OFFSET Par1,Mem1;
                INVOKE MessageBoxA,NULL,OFFSET lpERR6,OFFSET lpCapERR,uType
            .ELSE
                INVOKE MessageBoxA,NULL,OFFSET lpApp2,OFFSET lpCapApp,uType
            .ENDIF


            
            jmp ENDMESS
            
BUTTON3_CLICK:
            CALL  PurgeBuf                                                                   ;read port                          
            INVOKE ReadFile,HWNDCOM,OFFSET Buf, SIZEOF Buf,OFFSET LenBuf, NULL
            .IF EAX==0
                INVOKE GetLastError
                    mov Mem1,eax
                INVOKE wsprintf,OFFSET lpERR4(17),OFFSET Par1,Mem1;
                INVOKE MessageBoxA,NULL,OFFSET lpERR4,OFFSET lpCapERR,uType
            .ELSE
                INVOKE SendMessage,HWNDEDT1,WM_SETTEXT,SIZEOF Buf,OFFSET Buf
                INVOKE MessageBoxA,NULL,OFFSET lpApp3,OFFSET lpCapApp,uType
            .ENDIF
            jmp ENDMESS
            
BUTTON4_CLICK:                                                                  ;write port
                CALL  PurgeBuf
                INVOKE SendMessage,HWNDEDT2,WM_GETTEXT,SIZEOF Buf,OFFSET Buf
                INVOKE WriteFile,HWNDCOM,OFFSET Buf, SIZEOF Buf,OFFSET LenBuf, NULL
            .IF EAX==0
                INVOKE GetLastError
                    mov Mem1,eax
                INVOKE wsprintf,OFFSET lpERR5(18),OFFSET Par1,Mem1;
                INVOKE MessageBoxA,NULL,OFFSET lpERR5,OFFSET lpCapERR,uType
            .ELSE
                INVOKE MessageBoxA,NULL,OFFSET lpApp4,OFFSET lpCapApp,uType
            .ENDIF
 
            jmp ENDMESS



ENDMESS:
	xor    eax,eax
	ret
WndProc ENDP
                                                                ; clear buffer
PurgeBuf PROC
    push ebx
    push ecx
   
    mov cx,255
    mov ebx,offset Buf
    mov al,20h
 L:
    mov [ebx],al
    inc ebx
    LOOP L

    pop ecx
    pop ebx
    xor    eax,eax
    ret
PurgeBuf ENDP

END START

</font>
</pre>

<h4>Пример 3 Программа COMAPIc  v.1.00 на C, компилирована в MS VC6++ Enterpise SP6  в ОС XP SP3</h4>

<pre><font style="font-style : italic; font-size : 8pt; color :  blue ">	
// COMAPIc.cpp 
// www.softelectro
//Yshkardin V.

#include "stdafx.h"
#define STYLBTN WS_CHILD|BS_DEFPUSHBUTTON|WS_VISIBLE
#define STYLEDT WS_CHILD|WS_VISIBLE|WS_BORDER|WS_TABSTOP 

 		//data main window
	HINSTANCE hInst;											
	LPCTSTR szTitle="COMAPIc v.1.00";						
	LPCTSTR szWindowClass="SimpleWinClass";
		//data control
	LPCTSTR CLSBUTN="BUTTON";
	LPCTSTR CPBUT1="Open port";
	LPCTSTR CPBUT2="Close port";
	LPCTSTR CPBUT3="Read port";
	LPCTSTR CPBUT4="Write port";
	LPCTSTR CLSEDIT="EDIT";
	LPCTSTR CPEDT1;
	LPCTSTR CPEDT2="Hello World!";
	HWND HWNDBTN1;
	HWND HWNDBTN2;
	HWND HWNDBTN3;
	HWND HWNDBTN4;
	HWND HWNDEDT1;
	HWND HWNDEDT2;  
	HMENU ID_BTN1=(HMENU) 101;
	HMENU ID_BTN2=(HMENU) 102;
	HMENU ID_BTN3=(HMENU) 103;
	HMENU ID_BTN4=(HMENU) 104;
	
        //App message
	LPCTSTR  lpCapApp = "App message";
	char  lpApp1[40]   = "Open port HANDLE:";
	LPCTSTR  lpApp2    ="Close port";
	LPCTSTR  lpApp3    ="Data read: Ok";
	LPCTSTR  lpApp4    ="Data write: Ok";
    
        //error message
	LPCTSTR  lpCapERR  ="Error Message";       
	char lpERR1[40]={"Open port Error:"};
	char lpERR2[40]={"DCB Structure ERROR:"};
	char lpERR3[40]={"SetComm Function ERROR:"};
	char lpERR4[40]={"Read port ERROR:"};
	char lpERR5[40]={"Write port ERROR:"};
	char lpERR6[40]={"Close port ERROR:"};
	DWORD Mem1;
	LPCTSTR Par1        ="%lu";

		//data com port	
	HANDLE HWNDCOM;
	LPCTSTR lpNumCOM="COM1:";
	LPCTSTR COMSETTING="Com1: baud=1200 parity=N data=8 stop=1";
	char Buf[255];
	DWORD LenBuf;
	DCB DCB1;

	
LRESULT CALLBACK	WndProc(HWND, UINT, WPARAM, LPARAM);

void PurgeBuf()
{
	int a;
	for (a=0;a&lt;255;a++)
	{
		Buf[a]=0x20;
	}
	return;
}

int APIENTRY WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)
{
	
	MSG msg;
	WNDCLASSEX wcex;
	HWND hWnd;
    hInst=hInstance;

	wcex.cbSize = sizeof(WNDCLASSEX); 
	wcex.style			= CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc	= (WNDPROC)WndProc;
	wcex.cbClsExtra		= 0;
	wcex.cbWndExtra		= 0;
	wcex.hInstance		= hInstance;
	wcex.hIcon			= LoadIcon(NULL, IDI_APPLICATION);
	wcex.hIconSm		= 0;
	wcex.hCursor		= LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground	= (HBRUSH)(4);
	wcex.lpszMenuName	= 0;
	wcex.lpszClassName	= szWindowClass;
	RegisterClassEx(&amp;wcex);

	hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,20, 20, 800, 200, NULL, NULL, hInstance, NULL);

   if (!hWnd)
   {
      return FALSE;
   }

   ShowWindow(hWnd, SW_SHOWNORMAL);
   UpdateWindow(hWnd);


	

	while (GetMessage(&amp;msg, NULL, 0, 0)) 
	{
			TranslateMessage(&amp;msg);
			DispatchMessage(&amp;msg);
	}

	return 0;
}


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)

{	
	int wmId, wmEvent;
	int Retval;
	switch (message)

	{
		case WM_COMMAND:
				wmId    = LOWORD(wParam); 
				wmEvent = HIWORD(wParam); 
				switch (wmId)
			{
				case 101: //open port
					HWNDCOM=CreateFile(lpNumCOM, GENERIC_READ|GENERIC_WRITE, NULL, NULL, OPEN_EXISTING, NULL,NULL);
               
					if (HWNDCOM==INVALID_HANDLE_VALUE)
						{
							Mem1= GetLastError();
							wsprintf(&amp;lpERR1[16],Par1,Mem1);
							MessageBox(0,lpERR1,lpCapERR,0);
						}
					else
						{   
							wsprintf(&amp;lpApp1[17],Par1,HWNDCOM);
							MessageBoxA(0,lpApp1,lpCapApp,0);
							Retval=BuildCommDCB(COMSETTING,&amp;DCB1);
							if (Retval==0)	//error DCB
								{
									Mem1= GetLastError();
									wsprintf(&amp;lpERR2[20],Par1,Mem1);
									MessageBox(0,lpERR2,lpCapERR,0);
								}
							Retval=SetCommState(HWNDCOM,&amp;DCB1);
							if (Retval==0)	//error SetCom
								{
									Mem1= GetLastError();
									wsprintf(&amp;lpERR3[23],Par1,Mem1);
									MessageBox(0,lpERR3,lpCapERR,0);
								}
			   

						}
							break;

				case 102:			//close port
					Retval=CloseHandle(HWNDCOM);
					if (Retval==0) //error close port
						{
							Mem1= GetLastError();
							wsprintf(&amp;lpERR6[17],Par1,Mem1);
							MessageBox(0,lpERR6,lpCapERR,0);
						}
					else
						{
							MessageBox(0,lpApp2,lpCapApp,0);
						}
					break;

				case 103:		//read port
					PurgeBuf();
					Retval= ReadFile(HWNDCOM,&amp;Buf, 255,&amp;LenBuf, NULL);
					if (Retval==0) //error read port
						{
							Mem1= GetLastError();
							wsprintf(&amp;lpERR4[16],Par1,Mem1);
							MessageBox(0,lpERR4,lpCapERR,0);
						}
					else
						{
							SendMessageA(HWNDEDT1,WM_SETTEXT,sizeof Buf,(LPARAM) Buf);
							MessageBox(0,lpApp3,lpCapApp,0);
						}
           
						break;
				case 104:		//write port
					PurgeBuf();
					SendMessage(HWNDEDT2,WM_GETTEXT,sizeof Buf,(LPARAM) Buf);
					Retval= WriteFile(HWNDCOM,&amp;Buf, sizeof Buf,&amp;LenBuf, NULL);
					if (Retval==0) //error write port
						{
							Mem1= GetLastError();
							wsprintf(&amp;lpERR5[17],Par1,Mem1);
							MessageBox(0,lpERR5,lpCapERR,0);
						}
					else
						{
							MessageBox(0,lpApp4,lpCapApp,0);
						}
						break;
				default:
						{ 
							return DefWindowProc(hWnd, message, wParam, lParam);
						}
			}
			break;
		case WM_CREATE:
			HWNDBTN1= CreateWindowEx( 0,CLSBUTN,CPBUT1,STYLBTN,10,10,100,20,hWnd,ID_BTN1,hInst,0);
			HWNDBTN2= CreateWindowEx( 0,CLSBUTN,CPBUT2,STYLBTN,10,40,100,20,hWnd,ID_BTN2,hInst,0);
			HWNDBTN3= CreateWindowEx( 0,CLSBUTN,CPBUT3,STYLBTN,10,70,100,20,hWnd,ID_BTN3,hInst,0);
			HWNDBTN4= CreateWindowEx( 0,CLSBUTN,CPBUT4,STYLBTN,10,100,100,20,hWnd,ID_BTN4,hInst,0);
			HWNDEDT1= CreateWindowEx(0,CLSEDIT,CPEDT1,STYLEDT,120,70,600,20,hWnd,0,hInst,0);
			HWNDEDT2= CreateWindowEx(0,CLSEDIT,CPEDT2,STYLEDT,120,100,600,20,hWnd,0,hInst,0);

			break;
		case WM_DESTROY:
			PostQuitMessage(0);
			break;
		default:
			return DefWindowProc(hWnd, message, wParam, lParam);
   }
   return 0;
}





// stdafx.cpp : source file that includes just the standard includes
//	COMAPIc.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file




// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)

</windows.h></font>
</pre>

		
		
		
		
		
		<hr>

		<a target="_parent" href="http://www.softelectro.ru/proglang.html">Назад </a>&nbsp;
		<a target="_parent" href="http://www.softelectro.ru/index.html"> Главная  </a>&nbsp;
	
</body></html>