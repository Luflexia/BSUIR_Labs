display.c
#include "display.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ncurses.h>
#include "processes.h"
#include "threads.h"
#include "control.h"

void display_thread_info(const ThreadInfo *thread_info) {
    printw("%-5d %-8s %-5c %-9s %-9s %-4s %-10s -%s\n",
           thread_info->tid, "", thread_info->state, "", "", "", "", thread_info->name);
}

void display_header() {
    printw("%-5s %-8s %-5s %-9s %-9s %-5s %-9s %s\n",
           "PID", "USER", "STATE", "RES_MEM", "VIRT_MEM", "CORES", "START", "COMMAND");
}

void display_process_info(const ProcessInfo *proc_info) {
    // Обрезаем имя пользователя до 8 символов
    printw("%-5d %-8.8s %-5c %-6.1f MB %-6.1f MB %-5d %-9.8s ",
           proc_info->pid, proc_info->user, proc_info->state,
           proc_info->resident_memory, proc_info->virtual_memory,
           proc_info->cpu_cores, proc_info->start_time + 11);

    // Обрезаем имя команды до символа '/'
    char *slash_pos = strchr(proc_info->command, '/');
    if (slash_pos) {
        *slash_pos = '\0'; // Устанавливаем символ '/' как конец строки
    }
    printw("%s\n", proc_info->command);
}

void update_display(int start_line, int total_lines, ProcessData *process_data, int process_count, DisplayMode mode, ColorScheme color_scheme) {
    // Сортировка данных перед отображением
    switch (current_sort) {
        case SORT_BY_PID:
            qsort(process_data, process_count, sizeof(ProcessData), compare_by_pid);
        break;
        case SORT_BY_RESIDENT_MEMORY:
            qsort(process_data, process_count, sizeof(ProcessData), compare_by_resident_memory);
        break;
        case SORT_BY_VIRTUAL_MEMORY:
            qsort(process_data, process_count, sizeof(ProcessData), compare_by_virtual_memory);
        break;
    }

    clear(); // Очистка окна перед новым выводом
    display_header();
    int y = 1; // Текущая строка для вывода информации о процессе/потоке
    int line_count = 1; // Счетчик строк для вывода (учитываем строку заголовка)

    for (int i = 0; i < process_count && line_count < total_lines; i++) {
        if (line_count >= start_line && y < LINES) {
            move(y, 0);
            if (color_scheme == COLOR_SCHEME_INVERTED) {
                attron(COLOR_PAIR(2));
            } else {
                attron(COLOR_PAIR(1));
            }
            display_process_info(&process_data[i].process_info);
            y++;
        }
        line_count++;

        if (mode == SHOW_PROCESSES_AND_THREADS) {
            for (int j = 0; j < process_data[i].thread_count && line_count < total_lines; j++) {
                if (line_count >= start_line && y < LINES) {
                    move(y, 0);
                    if (color_scheme == COLOR_SCHEME_INVERTED) {
                        attron(COLOR_PAIR(2));
                    } else {
                        attron(COLOR_PAIR(1));
                    }
                    display_thread_info(&process_data[i].threads[j]);
                    y++;
                }
                line_count++;
            }
        }
    }
    refresh();
}

main.c
#include <curses.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <dirent.h>
#include <string.h>
#include "processes.h"
#include "display.h"
#include "threads.h"
#include "control.h"

#define MAX_PROCESSES 1000  // Максимальное количество процессов для отображения
#define REFRESH_INTERVAL 3000  // Интервал обновления в миллисекундах
#define SCROLL_LINES 20  // Количество строк для прокрутки по стрелкам

int main() {
    initscr();         // Инициализация ncurses
    start_color();     // Включение поддержки цвета
    noecho();          // Отключение эха вводимых символов
    cbreak();          // Включение режима cbreak
    keypad(stdscr, TRUE); // Включение поддержки клавиш
    mousemask(ALL_MOUSE_EVENTS, NULL); // Включение обработки всех событий мыши

    // Инициализация цветовых пар
    init_pair(1, COLOR_WHITE, COLOR_BLACK); // Стандартная цветовая схема (белый текст на черном фоне)
    init_pair(2, COLOR_BLACK, COLOR_WHITE); // Инвертированная цветовая схема (черный текст на белом фоне)

    int start_line = 0;  // Первая видимая строка
    int total_lines = 0; // Общее количество строк для отображения
    DisplayMode mode = SHOW_PROCESSES; // Режим отображения по умолчанию
    ColorScheme color_scheme = COLOR_SCHEME_DEFAULT; // Цветовая схема по умолчанию

    while (1) {
        DIR *dir;
        struct dirent *entry;

        dir = opendir("/proc");
        if (!dir) {
            perror("opendir(/proc)");
            endwin();
            return 1;
        }

        ProcessData process_data[MAX_PROCESSES]; // Сохранение информации о процессах и потоках
        int process_count = 0; // Обнуляем количество процессов
        total_lines = 1; // Обнуляем количество строк (учитываем строку заголовка)

        while ((entry = readdir(dir)) != NULL) {
            if (entry->d_type == DT_DIR) {  // Проверяем тип элемента и его идентификатор
                int pid = atoi(entry->d_name);  // Преобразуем имя каталога в целочисленный PID
                if (pid > 0 && process_count < MAX_PROCESSES) { // Проверяем, что PID положительный и количество процессов еще не достигло максимума
                    ProcessInfo proc_info;
                    get_process_info(&proc_info, pid); // Получаем информацию о процессе по его PID
                    process_data[process_count].process_info = proc_info; // Сохраняем информацию о процессе в массиве process_data
                    process_data[process_count].thread_count = 0; // Обнуляем счетчик потоков для данного процесса
                    total_lines++; // Увеличиваем общее количество строк для отображения

                    if (mode == SHOW_PROCESSES_AND_THREADS) {  // Если режим отображения включает информацию о потоках, получаем ее
                        char path[256];
                        DIR *task_dir;
                        struct dirent *task_entry;
                        snprintf(path, sizeof(path), "/proc/%d/task", proc_info.pid); // Формируем путь к каталогу с потоками процесса
                        task_dir = opendir(path); // Открываем каталог
                        if (task_dir) {
                            while ((task_entry = readdir(task_dir)) != NULL) {  // Перебираем все элементы в каталоге потоков
                                // Проверяем тип элемента и его имя
                                if (task_entry->d_type == DT_DIR && task_entry->d_name[0] !=
                                    '.' && process_data[process_count].thread_count < MAX_THREADS_PER_PROCESS) {
                                    int tid = atoi(task_entry->d_name);  // Преобразуем имя каталога в целочисленный TID
                                    ThreadInfo thread_info;
                                    get_thread_info(&thread_info, proc_info.pid, tid);  // Получаем информацию о потоке по его PID и TID
                                    process_data[process_count].threads[process_data[process_count].thread_count] = thread_info;
                                    process_data[process_count].thread_count++; // Увеличиваем счетчик потоков
                                    total_lines++; // Увеличиваем общее количество строк для отображения
                                }
                            }
                            closedir(task_dir);
                        }
                    }
                    process_count++;
                }
            }
        }
        closedir(dir);
        update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);

        timeout(REFRESH_INTERVAL);  // Устанавливаем таймаут ожидания ввода
        int ch = getch();
        if (ch == KEY_MOUSE) {
            MEVENT event;
            if (getmouse(&event) == OK) {
                if (event.bstate & BUTTON4_PRESSED) { // Прокрутка вверх
                    if (start_line > 0) start_line--;
                } else if (event.bstate & BUTTON5_PRESSED) { // Прокрутка вниз
                    // Увеличиваем начальную строку, если это возможно
                    if (start_line < total_lines - (LINES - 1)) start_line++;
                }
                update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);
            }
        } else if (ch == KEY_UP) {
            if (start_line > SCROLL_LINES) {
                start_line -= SCROLL_LINES;
            } else {
                start_line = 0; // Сбрасываем начало строки при переключении режима
            }
            update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);
        } else if (ch == KEY_DOWN) {
            if (start_line + SCROLL_LINES < total_lines - (LINES - 1)) {
                start_line += SCROLL_LINES;
            } else {
                start_line = total_lines - (LINES - 1);
                if (start_line < 0) start_line = 0;
            }
            update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);
        } else if (ch == 't') {
            if (mode == SHOW_PROCESSES) {
                mode = SHOW_PROCESSES_AND_THREADS;
            } else {
                mode = SHOW_PROCESSES;
            }
            start_line = 0;  // Сбрасываем начало строки при переключении режима
            update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);
        } else if (ch == 'z') {
            if (color_scheme == COLOR_SCHEME_DEFAULT) {
                // Включение инвертированной цветовой схемы для всего окна
                wbkgd(stdscr, COLOR_PAIR(2));
                color_scheme = COLOR_SCHEME_INVERTED;
            } else {
                // Включение стандартной цветовой схемы для всего окна
                wbkgd(stdscr, COLOR_PAIR(1));
                color_scheme = COLOR_SCHEME_DEFAULT;
            }
            start_line = 0;  // Сбрасываем начало строки при переключении цветовой схемы
            update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);
        } else if (ch == 'q') {
            break; // Завершение программы при нажатии 'q'
        } else if (ch == ERR) {
            // Таймаут достигнут, обновляем экран
            update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);
        }
        handle_user_input(ch);
        update_display(start_line, total_lines, process_data, process_count, mode, color_scheme);
    }

    endwin(); // Завершение работы ncurses
    return 0;
}

read.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>
#include <time.h>
#include "processes.h"
#include "threads.h"

void get_thread_info(ThreadInfo *thread_info, int pid, int tid) {
    char path[256];
    FILE *file;
    thread_info->tid = tid;

    snprintf(path, sizeof(path), "/proc/%d/task/%d/comm", pid, tid);
    file = fopen(path, "r");
    if (file) {
        if (fgets(thread_info->name, sizeof(thread_info->name), file)) {
            thread_info->name[strcspn(thread_info->name, "\n")] = '\0';
        }
        fclose(file);
    }

    snprintf(path, sizeof(path), "/proc/%d/task/%d/status", pid, tid);
    file = fopen(path, "r");
    if (file) {
        char buffer[256];
        while (fgets(buffer, sizeof(buffer), file)) {
            if (strncmp("State:", buffer, 6) == 0) {
                sscanf(buffer, "State: %c", &thread_info->state);
                break;
            }
        }
        fclose(file);
    }
}

// Функция для подсчета количества ядер
int count_cpu_cores(const char *cpu_list) {
    int cores = 1;
    for (const char *p = cpu_list; *p; p++) {
        if (*p == ',') {
            cores++;
        }
    }
    return cores;
}

// Функция для чтения времени запуска системы
time_t get_system_uptime() {
    FILE *file = fopen("/proc/uptime", "r");
    if (!file) {
        perror("Failed to open /proc/uptime");
        return 0;
    }
    double uptime;
    fscanf(file, "%lf", &uptime);
    fclose(file);
    return (time_t)uptime;
}

// Функция для чтения информации о процессе
void get_process_info(ProcessInfo *proc_info, int pid) {
    char path[256];
    char buffer[256];
    FILE *file;
    struct passwd *pw;

    // Заполняем PID
    proc_info->pid = pid;

    // Чтение информации из /proc/[pid]/status для получения имени пользователя, состояния процесса, виртуальной памяти и команды
    snprintf(path, sizeof(path), "/proc/%d/status", pid);
    file = fopen(path, "r");
    if (file) {
        while (fgets(buffer, sizeof(buffer), file)) {
            if (strncmp(buffer, "Uid:", 4) == 0) {
                int uid;
                sscanf(buffer, "Uid: %d", &uid);
                pw = getpwuid(uid);
                if (pw) {
                    strncpy(proc_info->user, pw->pw_name, sizeof(proc_info->user) - 1);
                }
            } else if (strncmp(buffer, "VmSize:", 7) == 0) {
                unsigned long vm_size;
                sscanf(buffer, "VmSize: %lu kB", &vm_size);
                proc_info->virtual_memory = vm_size / 1024.0 / 1024.0; // Конвертируем в MB
            } else if (strncmp(buffer, "State:", 6) == 0) {
                sscanf(buffer, "State: %c", &proc_info->state);
            } else if (strncmp(buffer, "Name:", 5) == 0) {
                sscanf(buffer, "Name: %s", proc_info->command);
            } else if (strncmp(buffer, "Cpus_allowed_list:", 18) == 0) {
                // Здесь считываем информацию о привязке к ядрам
                char cpu_list[256];
                sscanf(buffer, "Cpus_allowed_list: %s", cpu_list);
                proc_info->cpu_cores = count_cpu_cores(cpu_list); // Подсчитываем количество ядер
            } else if (strncmp(buffer, "Threads:", 8) == 0) {
                sscanf(buffer, "Threads: %d", &proc_info->threads);
            }
        }
        fclose(file);
    }

    // Чтение информации из /proc/[pid]/stat для получения потребления физической памяти и времени запуска
    snprintf(path, sizeof(path), "/proc/%d/stat", pid);
    file = fopen(path, "r");
    if (file) {
        long rss;
        unsigned long utime, stime, starttime;
        fscanf(file, "%*d %*s %*c %*d %*d %*d %*d %*d %*d %*u %*u %*u %*u %lu %lu %*d %*d %*d %*d %llu", &utime, &stime, &starttime);
        fclose(file);

        // Получаем текущее время в секундах
        time_t now = time(NULL);
        // Время работы системы в секундах
        time_t uptime = get_system_uptime();
        // Время запуска процесса (текущее время - (время работы системы - время старта процесса))
        time_t start_time = now - (uptime - (starttime / sysconf(_SC_CLK_TCK)));

        struct tm start_tm;
        localtime_r(&start_time, &start_tm);
        strftime(proc_info->start_time, sizeof(proc_info->start_time), "%Y-%m-%d %H:%M:%S", &start_tm);

        snprintf(path, sizeof(path), "/proc/%d/statm", pid);
        file = fopen(path, "r");
        if (file) {
            fscanf(file, "%*d %ld", &rss);
            fclose(file);
            proc_info->resident_memory = rss * (sysconf(_SC_PAGESIZE) / 1024.0 / 1024.0); // Конвертируем в MB
        }
    }
}


я хочу второй заголовок в display.c функцией display_sinfo, который будет показывать название программы, текущее время, количество пользователей, сколько сейчас запущено процессов, сколько потоков, сколько из процессов со статусом r s i z
сделай структуру Sinfo в Sinfo.h в которой будут хранится данные, и реализуй функциюю в read.c по заполнению ее реальными данными